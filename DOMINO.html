<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ†Ùˆ Ù„Ù„Ù…Ø­ØªØ±ÙÙŠÙ†</title>
    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a472a;
            /* Ø·Ø§ÙˆÙ„Ø© Ø®Ø¶Ø±Ø§Ø¡ ØºØ§Ù…Ù‚Ø© */
            --tile-color: #f0f0f0;
            --tile-shadow: #000;
            --highlight: #ffd700;
        }

        body {
            font-family: 'Cairo', sans-serif;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at center, #2e7d32 0%, #1b5e20 100%);
            color: white;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
        }

        /* Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø© */
        #game-layout {
            display: grid;
            grid-template-rows: auto 1fr auto;
            height: 100%;
            width: 100%;
        }

        /* 1. ÙŠØ¯ Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± (Ø§Ù„Ø£Ø¹Ù„Ù‰) */
        #top-area {
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.2);
        }

        /* 2. Ø§Ù„Ø·Ø§ÙˆÙ„Ø© (Ø§Ù„ÙˆØ³Ø·) */
        #board-area {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            flex: 1;
            padding: 40px;
            /* Ø¥Ø¶Ø§ÙØ© Ù†Ø³ÙŠØ¬ Ø®Ø´Ø¨ÙŠ Ø®ÙÙŠÙ Ù„Ù„Ø·Ø§ÙˆÙ„Ø© */
            background-image: repeating-linear-gradient(45deg, rgba(255, 255, 255, 0.03) 0, rgba(255, 255, 255, 0.03) 1px, transparent 1px, transparent 10px);
        }

        #board-content {
            display: flex;
            align-items: center;
            gap: 2px;
            min-width: min-content;
            /* Ù„Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ØªÙ…Ø¯Ø¯ */
            padding: 50px;
        }

        /* 3. ÙŠØ¯ Ø§Ù„Ù„Ø§Ø¹Ø¨ (Ø§Ù„Ø£Ø³ÙÙ„) */
        #bottom-area {
            padding: 15px;
            background: rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.5);
        }

        /* ØªØµÙ…ÙŠÙ… Ù‚Ø·Ø¹Ø© Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ†Ùˆ */
        .tile {
            width: 44px;
            height: 88px;
            background: var(--tile-color);
            border-radius: 6px;
            box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            position: relative;
            transition: transform 0.2s, margin 0.3s;
        }

        /* Ø§Ù„Ø®Ø· Ø§Ù„ÙØ§ØµÙ„ */
        .tile::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 5px;
            right: 5px;
            height: 1px;
            background: #ccc;
        }

        /* Ù„Ù„Ù†ØµÙÙŠÙ† */
        .half {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Ø§Ù„Ù†Ù‚Ø§Ø· */
        .dot {
            width: 8px;
            height: 8px;
            background: black;
            border-radius: 50%;
            position: absolute;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.6);
        }

        /* Ù…ÙˆØ§Ø¶Ø¹ Ø§Ù„Ù†Ù‚Ø§Ø· */
        .p1 {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .p2-tl {
            top: 20%;
            left: 20%;
        }

        .p2-br {
            bottom: 20%;
            right: 20%;
        }

        .p2-tr {
            top: 20%;
            right: 20%;
        }

        .p2-bl {
            bottom: 20%;
            left: 20%;
        }

        .p-mid-l {
            top: 50%;
            left: 20%;
            transform: translateY(-50%);
        }

        .p-mid-r {
            top: 50%;
            right: 20%;
            transform: translateY(-50%);
        }

        /* Ù‚Ø·Ø¹ Ø§Ù„Ø®ØµÙ… (Ù…Ù‚Ù„ÙˆØ¨Ø©) */
        .tile.hidden {
            background: #3e2723;
            background-image: linear-gradient(45deg, #4e342e 25%, transparent 25%, transparent 75%, #4e342e 75%, #4e342e),
                linear-gradient(45deg, #4e342e 25%, transparent 25%, transparent 75%, #4e342e 75%, #4e342e);
            background-size: 10px 10px;
            background-position: 0 0, 5px 5px;
        }

        .tile.hidden::after,
        .tile.hidden .dot {
            display: none;
        }

        /* Ù‚Ø·Ø¹ Ø§Ù„Ø·Ø§ÙˆÙ„Ø© (Ø£ÙÙ‚ÙŠØ©) */
        .tile.horizontal {
            width: 88px;
            height: 44px;
            flex-direction: row;
        }

        .tile.horizontal::after {
            top: 5px;
            bottom: 5px;
            left: 50%;
            right: auto;
            width: 1px;
            height: auto;
        }

        /* Ù‚Ø·Ø¹ Ø§Ù„Ø¯ÙˆØ¨Ù„ ÙÙŠ Ø§Ù„Ø·Ø§ÙˆÙ„Ø© (Ø¹Ù…ÙˆØ¯ÙŠØ©) */
        .tile.double-bone {
            /* Ù†Ø­Ø§ÙØ¸ Ø¹Ù„ÙŠÙ‡Ø§ Ø¹Ù…ÙˆØ¯ÙŠØ© Ù„Ù„ØªÙ…ÙŠØ² */
            transform: scale(0.95);
        }

        /* ØªÙØ§Ø¹Ù„ ÙŠØ¯ Ø§Ù„Ù„Ø§Ø¹Ø¨ */
        .my-hand .tile {
            cursor: pointer;
            margin: 0 5px;
        }

        .my-hand .tile:hover {
            transform: translateY(-15px);
            z-index: 100;
        }

        .my-hand .tile.disabled {
            filter: grayscale(0.8) opacity(0.6);
            cursor: not-allowed;
        }

        /* Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ… */
        #controls {
            margin-top: 10px;
            display: flex;
            gap: 15px;
        }

        button {
            padding: 10px 25px;
            border: none;
            border-radius: 8px;
            font-family: 'Cairo';
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: 0.2s;
        }

        .btn-green {
            background: #4caf50;
            color: white;
        }

        .btn-green:hover {
            background: #388e3c;
        }

        .btn-red {
            background: #f44336;
            color: white;
        }

        .btn-red:hover {
            background: #d32f2f;
        }

        #status-msg {
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 20px;
            border-radius: 20px;
            font-size: 1.1rem;
            color: #ffd700;
        }

        /* Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ø¯ÙˆØ± */
        .turn-indicator {
            padding: 5px 10px;
            border-radius: 5px;
        }

        .active-turn {
            background: rgba(255, 215, 0, 0.3);
            border: 1px solid gold;
        }
    </style>
</head>

<body>

    <div id="game-layout">
        <!-- Ù…Ù†Ø·Ù‚Ø© Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± -->
        <div id="top-area">
            <div class="turn-indicator" id="comp-indicator">
                ğŸ‘¤ Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±: <span id="comp-count">7</span> Ù‚Ø·Ø¹
            </div>
            <div id="comp-hand" style="display:flex; margin-right:20px; transform: scale(0.7);">
                <!-- Ø³ÙŠØªÙ… ØªÙˆÙ„ÙŠØ¯Ù‡Ø§ Ø¨Ø§Ù„Ø¬Ø§ÙØ§Ø³ÙƒØ±ÙŠØ¨Øª -->
            </div>
        </div>

        <!-- Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ø·Ø§ÙˆÙ„Ø© -->
        <div id="board-area">
            <div id="board-content">
                <!-- Ø§Ù„Ù‚Ø·Ø¹ Ø§Ù„Ù…Ù„Ø¹ÙˆØ¨Ø© -->
            </div>
        </div>

        <!-- Ù…Ù†Ø·Ù‚Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ -->
        <div id="bottom-area">
            <div id="status-msg">Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ! Ø§Ø¶ØºØ· "Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨"</div>

            <div id="my-hand" class="my-hand" style="display:flex; margin: 15px 0;">
                <!-- Ù‚Ø·Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ -->
            </div>

            <div id="controls">
                <button id="btn-start" class="btn-green" onclick="startGame()">Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨</button>
                <button id="btn-draw" class="btn-green" onclick="drawFromMarket()" disabled>Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„Ø³ÙˆÙ‚ (<span
                        id="market-count">14</span>)</button>
                <button id="btn-pass" class="btn-red" onclick="passTurn()" disabled>ØªØ®Ø·ÙŠ Ø§Ù„Ø¯ÙˆØ±</button>
            </div>
        </div>
    </div>

    <script>
        // --- Ù…Ù†Ø·Ù‚ Ø§Ù„Ù„Ø¹Ø¨Ø© ---

        // ØªØ¹Ø±ÙŠÙØ§Øª
        let deck = [];
        let players = { me: [], comp: [] };
        let board = []; // Array of { top, bottom, isDouble } but we need orientation logic
        let market = [];
        let gameActive = false;
        let isMyTurn = false;

        // ØªØªØ¨Ø¹ Ø£Ø·Ø±Ø§Ù Ø§Ù„Ø³Ù„Ø³Ù„Ø©
        let chainHead = null; // Ø§Ù„Ø·Ø±Ù Ø§Ù„Ø£ÙŠØ³Ø±
        let chainTail = null; // Ø§Ù„Ø·Ø±Ù Ø§Ù„Ø£ÙŠÙ…Ù†

        // ØªØ´ÙƒÙŠÙ„Ø§Øª Ø§Ù„Ù†Ù‚Ø§Ø· Ù„Ù„Ø±Ø³Ù… (CSS Classes)
        const dotMap = {
            0: [],
            1: ['p1'],
            2: ['p2-tr', 'p2-bl'],
            3: ['p2-tr', 'p1', 'p2-bl'],
            4: ['p2-tl', 'p2-tr', 'p2-bl', 'p2-br'],
            5: ['p2-tl', 'p2-tr', 'p1', 'p2-bl', 'p2-br'],
            6: ['p2-tl', 'p2-tr', 'p-mid-l', 'p-mid-r', 'p2-bl', 'p2-br']
        };

        function createTile(v1, v2) {
            return { v1, v2, id: Math.random().toString(36) };
        }

        function initDeck() {
            let d = [];
            for (let i = 0; i <= 6; i++) {
                for (let j = i; j <= 6; j++) {
                    d.push(createTile(i, j));
                }
            }
            // Ø®Ù„Ø·
            for (let i = d.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [d[i], d[j]] = [d[j], d[i]];
            }
            return d;
        }

        function startGame() {
            deck = initDeck();
            players.me = deck.splice(0, 7);
            players.comp = deck.splice(0, 7);
            market = deck; // Ø§Ù„Ø¨Ø§Ù‚ÙŠ (14 Ù‚Ø·Ø¹Ø©)
            board = [];
            chainHead = null; chainTail = null;
            gameActive = true;

            document.getElementById('btn-start').innerText = "Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø¹Ø¨";
            document.getElementById('btn-start').classList.replace('btn-green', 'btn-red');

            // Ù…Ù† ÙŠØ¨Ø¯Ø£ØŸ
            // Ù‚Ø§Ø¹Ø¯Ø©: ØµØ§Ø­Ø¨ Ø£ÙƒØ¨Ø± Ø¯ÙˆØ¨Ù„ØŒ Ø£Ùˆ Ø£ÙƒØ¨Ø± Ù‚Ø·Ø¹Ø© Ø¥Ø°Ø§ Ù„Ù… ÙŠÙˆØ¬Ø¯.
            // Ù„Ù„ØªØ¨Ø³ÙŠØ·: Ø³Ù†Ø¶Ø¹ Ù‚Ø·Ø¹Ø© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù…Ù† Ø§Ù„Ø³ÙˆÙ‚ Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨ ÙÙˆØ±Ø§Ù‹
            const starter = market.pop();

            // ÙˆØ¶Ø¹ Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ ÙÙŠ Ø§Ù„Ø·Ø§ÙˆÙ„Ø©
            // ÙÙŠ Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ†ÙˆØŒ Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰ Ù„Ù‡Ø§ Ø·Ø±ÙØ§Ù† Ù…ÙØªÙˆØ®Ø§Ù†
            board.push({
                v1: starter.v1,
                v2: starter.v2,
                element: createTileDom(starter.v1, starter.v2, starter.v1 === starter.v2, false)
            });

            chainHead = starter.v1;
            chainTail = starter.v2;

            renderHand('me');
            renderHand('comp');
            renderBoard();
            updateUI("Ø¨Ø¯Ø£Øª Ø§Ù„Ù„Ø¹Ø¨Ø©! Ø¯ÙˆØ±Ùƒ Ø§Ù„Ø¢Ù†.");

            isMyTurn = true;
            checkMoves();
        }

        // --- Ù…Ù†Ø·Ù‚ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø­Ø±ÙƒØ§Øª ---

        function getValidMove(tile) {
            // tile has v1, v2.
            // board has chainHead (Left end), chainTail (Right end).

            // Check fit with Head (Left)
            // Ù†Ø±ÙŠØ¯ Ù…Ø·Ø§Ø¨Ù‚Ø© Ø£Ø­Ø¯ Ø±Ù‚Ù…ÙŠ Ø§Ù„Ù‚Ø·Ø¹Ø© Ù…Ø¹ Head. Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ù…Ø·Ø§Ø¨Ù‚ ÙŠØ´Ø¨ÙƒØŒ ÙˆØ§Ù„Ø±Ù‚Ù… Ø§Ù„Ø¢Ø®Ø± ÙŠØµØ¨Ø­ Head Ø§Ù„Ø¬Ø¯ÙŠØ¯.
            if (tile.v1 === chainHead) return { side: 'head', connect: 'v1', newExposed: tile.v2 };
            if (tile.v2 === chainHead) return { side: 'head', connect: 'v2', newExposed: tile.v1 };

            // Check fit with Tail (Right)
            if (tile.v1 === chainTail) return { side: 'tail', connect: 'v1', newExposed: tile.v2 };
            if (tile.v2 === chainTail) return { side: 'tail', connect: 'v2', newExposed: tile.v1 };

            return null;
        }

        // --- ØªÙØ§Ø¹Ù„ Ø§Ù„Ù„Ø§Ø¹Ø¨ ---

        function onTileClick(index) {
            if (!gameActive || !isMyTurn) return;

            const tile = players.me[index];
            const move = getValidMove(tile);

            if (move) {
                playMove('me', index, tile, move);
            } else {
                playSound('error');
                updateUI("Ø­Ø±ÙƒØ© ØºÙŠØ± Ù…Ù…ÙƒÙ†Ø©!");
            }
        }

        function playMove(who, index, tile, move) {
            // 1. Remove from hand
            if (who === 'me') players.me.splice(index, 1);
            else players.comp.splice(index, 1);

            // 2. Add to board logic
            // Ù†Ø­ØªØ§Ø¬ Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ø¨ØµØ±ÙŠ (Ù…Ù‚Ù„ÙˆØ¨Ø© Ø£Ù… Ù„Ø§)
            // Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ØµØ±ÙŠØ©:
            // Ø¹Ù†Ø¯ Ø§Ù„Ù„Ø¹Ø¨ Ø¹Ù„Ù‰ Ø§Ù„ÙŠÙ…ÙŠÙ† (Tail): Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø£ÙŠØ³Ø± Ù…Ù† Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ·Ø§Ø¨Ù‚ chainTail.
            // Ø¹Ù†Ø¯ Ø§Ù„Ù„Ø¹Ø¨ Ø¹Ù„Ù‰ Ø§Ù„ÙŠØ³Ø§Ø± (Head): Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø£ÙŠÙ…Ù† Ù…Ù† Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ·Ø§Ø¨Ù‚ chainHead.

            let visualV1, visualV2;  // Left-half, Right-half values

            if (move.side === 'tail') {
                // Ù†Ø¶ÙŠÙ Ù„Ù„ÙŠÙ…ÙŠÙ†.
                // Ø³Ù„Ø³Ù„Ø©: [Head ... Tail] + [Tile]
                // ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ·Ø§Ø¨Ù‚ ÙŠØ³Ø§Ø± Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© (visualV1) Ù‚ÙŠÙ…Ø© Tail.
                // Ø¥Ø°Ø§ ÙƒØ§Ù† connect Ù‡Ùˆ v1ØŒ ÙÙ‡Ø°Ø§ ÙŠØ¹Ù†ÙŠ v1 Ù‡Ùˆ Ø§Ù„Ø°ÙŠ Ø·Ø§Ø¨Ù‚ Tail. Ø¥Ø°Ù† v1 ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† ÙŠØ³Ø§Ø±.
                if (move.connect === 'v1') {
                    visualV1 = tile.v1; visualV2 = tile.v2;
                } else {
                    visualV1 = tile.v2; visualV2 = tile.v1;
                }
                chainTail = move.newExposed;

                // Ø¥Ø¶Ø§ÙØ© Ù„Ù…ØµÙÙˆÙØ© Ø§Ù„Ù„ÙˆØ­Ø©
                board.push({
                    v1: visualV1, v2: visualV2,
                    element: createTileDom(visualV1, visualV2, visualV1 === visualV2, true) // true = horizontal usually
                });

            } else { // head
                // Ù†Ø¶ÙŠÙ Ù„Ù„ÙŠØ³Ø§Ø±.
                // [Tile] + [Head ... Tail]
                // ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ·Ø§Ø¨Ù‚ ÙŠÙ…ÙŠÙ† Ø§Ù„Ù‚Ø·Ø¹Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© (visualV2) Ù‚ÙŠÙ…Ø© Head.
                // Ø¥Ø°Ø§ ÙƒØ§Ù† connect Ù‡Ùˆ v1ØŒ ÙÙ‡Ø°Ø§ ÙŠØ¹Ù†ÙŠ v1 Ø·Ø§Ø¨Ù‚ Head. Ø¥Ø°Ù† v1 ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† ÙŠÙ…ÙŠÙ†.
                if (move.connect === 'v1') {
                    visualV1 = tile.v2; visualV2 = tile.v1;
                } else {
                    visualV1 = tile.v1; visualV2 = tile.v2;
                }
                chainHead = move.newExposed;

                board.unshift({
                    v1: visualV1, v2: visualV2,
                    element: createTileDom(visualV1, visualV2, visualV1 === visualV2, true)
                });
            }

            renderBoard();
            renderHand('me');
            renderHand('comp');

            // ÙØ­Øµ Ø§Ù„ÙÙˆØ²
            if (who === 'me' && players.me.length === 0) return gameOver('me');
            if (who === 'comp' && players.comp.length === 0) return gameOver('comp');

            // ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø¯ÙˆØ±
            if (gameActive) {
                isMyTurn = !isMyTurn;
                checkMoves();
                if (!isMyTurn) setTimeout(compTurn, 1000);
            }
        }

        // --- Ø¯ÙˆØ± Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± ---
        function compTurn() {
            if (!gameActive) return;

            // 1. Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù‚Ø·Ø¹Ø©
            let bestMove = null;
            let bestIndex = -1;

            // Ø§Ø³ØªØ±Ø§ØªÙŠØ¬ÙŠØ© Ø¨Ø³ÙŠØ·Ø©: Ø§Ù„Ø¹Ø¨ Ø£ÙƒØ¨Ø± Ù‚Ø·Ø¹Ø© (Ù„ØªØªØ®Ù„Øµ Ù…Ù† Ø§Ù„Ù†Ù‚Ø§Ø·)
            // Ø£Ùˆ Ø§Ù„Ø¹Ø¨ Ø§Ù„Ø¯ÙˆØ¨Ù„
            let possibleMoves = [];

            players.comp.forEach((t, i) => {
                const m = getValidMove(t);
                if (m) possibleMoves.push({ i, t, m });
            });

            if (possibleMoves.length > 0) {
                // Ø§Ø®ØªØ± Ø¹Ø´ÙˆØ§Ø¦ÙŠØ§Ù‹ Ø£Ùˆ Ø§Ù„Ø£ÙƒØ¨Ø±
                const choice = possibleMoves.sort((a, b) => (b.t.v1 + b.t.v2) - (a.t.v1 + a.t.v2))[0];
                playMove('comp', choice.i, choice.t, choice.m);
            } else {
                // Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù†Ù‚Ù„Ø© -> Ø³Ø­Ø¨
                if (market.length > 0) {
                    updateUI("Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± ÙŠØ³Ø­Ø¨...");
                    setTimeout(() => {
                        players.comp.push(market.pop());
                        renderHand('comp');
                        compTurn(); // Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
                    }, 800);
                } else {
                    // ØªÙ…Ø±ÙŠØ±
                    updateUI("Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± Ù…Ø±Ø± Ø§Ù„Ø¯ÙˆØ±!");
                    isMyTurn = true;
                    checkMoves(); // Check if player is blocked too
                }
            }
        }

        function checkMoves() {
            // ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ø£Ø²Ø±Ø§Ø±
            document.getElementById('market-count').innerText = market.length;
            document.getElementById('comp-count').innerText = players.comp.length;

            if (!isMyTurn) {
                updateUI("Ø¯ÙˆØ± Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±...");
                disableControls();
                return;
            }

            // Ø¯ÙˆØ±ÙŠ: Ù‡Ù„ Ø£Ù…Ù„Ùƒ Ù†Ù‚Ù„Ø©ØŸ
            const canMove = players.me.some(t => getValidMove(t));

            const btnDraw = document.getElementById('btn-draw');
            const btnPass = document.getElementById('btn-pass');

            if (canMove) {
                btnDraw.disabled = true;
                btnPass.disabled = true;
                updateUI("Ø¯ÙˆØ±Ùƒ: Ø§Ø®ØªØ± Ù‚Ø·Ø¹Ø© Ù„Ù„Ø¹Ø¨.");
            } else {
                // Ù„Ø§ Ø£Ù…Ù„Ùƒ Ù†Ù‚Ù„Ø©
                if (market.length > 0) {
                    btnDraw.disabled = false;
                    btnPass.disabled = true;
                    updateUI("Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†Ù‚Ù„Ø© Ù…ØªØ§Ø­Ø©! Ø§Ø³Ø­Ø¨ Ù…Ù† Ø§Ù„Ø³ÙˆÙ‚.");
                } else {
                    // Ø§Ù„Ø³ÙˆÙ‚ ÙØ§Ø±Øº
                    btnDraw.disabled = true;
                    btnPass.disabled = false;
                    updateUI("Ù„Ø§ ØªÙˆØ¬Ø¯ Ù†Ù‚Ù„Ø© ÙˆØ§Ù„Ø³ÙˆÙ‚ ÙØ§Ø±Øº! Ø§Ø¶ØºØ· ØªØ®Ø·ÙŠ.");

                    // Check blockage
                    const compCan = players.comp.some(t => getValidMove(t));
                    if (!compCan && market.length === 0) gameOver('blocked');
                }
            }
        }

        function drawFromMarket() {
            if (market.length === 0) return;
            players.me.push(market.pop());
            renderHand('me');
            checkMoves();
        }

        function passTurn() {
            isMyTurn = false;
            checkMoves();
            setTimeout(compTurn, 500);
        }

        function gameOver(winner) {
            gameActive = false;
            disableControls();
            if (winner === 'me') updateUI("ğŸ‰ Ù…Ø¨Ø±ÙˆÙƒ! Ù„Ù‚Ø¯ ÙØ²Øª!");
            else if (winner === 'comp') updateUI("ğŸ˜• Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± ÙØ§Ø²! Ø­Ø¸ Ø£ÙˆÙØ±.");
            else {
                // Blocked
                let s1 = players.me.reduce((a, b) => a + b.v1 + b.v2, 0);
                let s2 = players.comp.reduce((a, b) => a + b.v1 + b.v2, 0);
                if (s1 < s2) updateUI(`Ù‚ÙÙ„Øª! Ø£Ù†Øª Ø§Ù„ÙØ§Ø¦Ø² Ø¨Ø§Ù„Ù†Ù‚Ø§Ø· (${s1} vs ${s2})`);
                else updateUI(`Ù‚ÙÙ„Øª! Ø§Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± ÙØ§Ø² Ø¨Ø§Ù„Ù†Ù‚Ø§Ø· (${s2} vs ${s1})`);
            }
        }

        function disableControls() {
            document.getElementById('btn-draw').disabled = true;
            document.getElementById('btn-pass').disabled = true;
        }

        function updateUI(msg) {
            document.getElementById('status-msg').innerText = msg;
        }

        function playSound(type) {
            // Placeholder
        }

        // --- ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø±Ø³Ù… DOM ---

        function createTileDom(v1, v2, isDouble, isHorizontal) {
            const el = document.createElement('div');
            // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø¯Ø¨Ù„ØŒ Ù†ÙØ¶Ù„ Ø¬Ø¹Ù„Ù‡Ø§ Ø¹Ù…ÙˆØ¯ÙŠØ© (Ø¨Ø¯ÙˆÙ† ÙƒÙ„Ø§Ø³ horizontal) Ù„ØªÙ…ÙŠÙŠØ²Ù‡Ø§ ÙƒÙ…Ø§ ÙÙŠ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©
            // Ø£Ù…Ø§ Ø§Ù„Ø¹Ø§Ø¯ÙŠØ© ÙÙ‡ÙŠ Ø£ÙÙ‚ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ø·Ø§ÙˆÙ„Ø©

            let cls = 'tile';
            if (isHorizontal && !isDouble) cls += ' horizontal';
            if (isDouble) cls += ' double-bone'; // Custom styling for doubles

            el.className = cls;

            // Top/Left part
            const half1 = document.createElement('div');
            half1.className = 'half';
            addDots(half1, v1);

            // Bottom/Right part
            const half2 = document.createElement('div');
            half2.className = 'half';
            addDots(half2, v2);

            el.appendChild(half1);
            el.appendChild(half2);

            return el;
        }

        function addDots(container, val) {
            dotMap[val].forEach(c => {
                const d = document.createElement('div');
                d.className = 'dot ' + c;
                container.appendChild(d);
            });
        }

        function renderHand(who) {
            const c = document.getElementById(who === 'me' ? 'my-hand' : 'comp-hand');
            c.innerHTML = '';
            const hand = players[who];

            hand.forEach((tile, idx) => {
                if (who === 'comp' && gameActive) {
                    // Hidden tile
                    const t = document.createElement('div');
                    t.className = 'tile hidden';
                    c.appendChild(t);
                } else {
                    const t = createTileDom(tile.v1, tile.v2, tile.v1 === tile.v2, false);
                    if (who === 'me') {
                        // Check validity for visualizing disabled state
                        if (!getValidMove(tile) && gameActive && isMyTurn) {
                            t.classList.add('disabled');
                        }
                        t.onclick = () => onTileClick(idx);
                    }
                    c.appendChild(t);
                }
            });
        }

        function renderBoard() {
            const c = document.getElementById('board-content');
            c.innerHTML = '';
            board.forEach(b => {
                c.appendChild(b.element);
            });

            // Auto scroll to latest?
            // c.scrollLeft = c.scrollWidth; // No, maybe center?
        }

    </script>
</body>

</html>
