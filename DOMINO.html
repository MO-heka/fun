<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DOMINO HEKA ULTRA</title>
    <link href="https://fonts.googleapis.com/css2?family=Righteous&family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    
    <style>
        :root { 
            --bg-color: #0f172a; 
            --glass-bg: rgba(30, 41, 59, 0.95);
            --domino-white: #f1f2f6;
            --domino-black: #1e272e;
            --accent-color: #3b82f6; 
            --gold: #fbbf24;
            --danger: #ef4444;
            --drop-zone: rgba(251, 191, 36, 0.4);
        }

        body { 
            font-family: 'Cairo', sans-serif; 
            background-color: var(--bg-color);
            background-image: radial-gradient(#1e293b 15%, transparent 16%), radial-gradient(#1e293b 15%, transparent 16%);
            background-size: 60px 60px;
            color: #e2e8f0; margin: 0; overflow: hidden; height: 100vh;
            display: flex; flex-direction: column; user-select: none;
            touch-action: none;
        }

        h1.game-title {
            font-family: 'Righteous', cursive; font-size: 1.8rem; color: var(--gold);
            text-shadow: 0 0 15px rgba(251, 191, 36, 0.4); margin: 10px 0; text-align: center; pointer-events: none;
        }
        #screen-game h1.game-title { display: none; } 

        .container { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; position: relative; }
        .hidden { display: none !important; }

        .screen {
            background: var(--glass-bg); backdrop-filter: blur(12px); padding: 30px;
            border-radius: 20px; text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1); width: 90%; max-width: 400px; z-index: 100;
        }

        input { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); padding: 10px; color: white; border-radius: 8px; text-align: center; outline: none; }
        button { background: var(--accent-color); color: white; padding: 10px 20px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; transition: 0.3s; margin: 5px; font-family: 'Cairo'; }
        button:active { transform: scale(0.95); }

        /* ÿßŸÑÿØŸàŸÖŸäŸÜŸà */
        .domino { 
            background-color: var(--domino-white); border-radius: 4px; box-shadow: 2px 2px 0px #555; 
            display: flex; cursor: pointer; position: absolute; 
            transition: all 0.3s ease; transform-origin: center center;
            border: 1px solid #999;
        }
        .pip-container { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); padding: 2px; width: 100%; height: 100%; box-sizing: border-box; }
        .pip { background-color: var(--domino-black); border-radius: 50%; width: 100%; height: 100%; box-shadow: inset 0 1px 1px rgba(0,0,0,0.5); }
        .line { background-color: #ccc; }

        .p1 { grid-area: 2 / 2; } .p2-1 { grid-area: 1 / 3; } .p2-2 { grid-area: 3 / 1; }
        .p3-1 { grid-area: 1 / 3; } .p3-2 { grid-area: 2 / 2; } .p3-3 { grid-area: 3 / 1; }
        .p4-1 { grid-area: 1 / 1; } .p4-2 { grid-area: 1 / 3; } .p4-3 { grid-area: 3 / 1; } .p4-4 { grid-area: 3 / 3; }
        .p5-1 { grid-area: 1 / 1; } .p5-2 { grid-area: 1 / 3; } .p5-3 { grid-area: 2 / 2; } .p5-4 { grid-area: 3 / 1; } .p5-5 { grid-area: 3 / 3; }
        .p6-1 { grid-area: 1 / 1; } .p6-2 { grid-area: 1 / 3; } .p6-3 { grid-area: 2 / 1; } .p6-4 { grid-area: 2 / 3; } .p6-5 { grid-area: 3 / 1; } .p6-6 { grid-area: 3 / 3; }

        /* ÿ™ÿπÿØŸäŸÑ ÿßŸÑŸäÿØ: ÿ±ŸÅÿπ ÿßŸÑŸÉÿ±Ÿàÿ™ ŸÑÿ£ÿπŸÑŸâ */
        .hand-tile { 
            position: relative; width: 36px; height: 72px; flex-direction: column; margin: 0 4px; z-index: 10; flex-shrink: 0;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
        }
        .hand-tile .line { height: 2px; width: 90%; margin: 2px auto; }
        .hand-tile .pip-container { width: 36px; height: 35px; } .hand-tile .pip { width: 6px; height: 6px; margin: auto; }
        .hand-tile.selected { transform: translateY(-35px) scale(1.15); box-shadow: 0 0 20px var(--gold); border: 2px solid var(--gold); z-index: 50; }

        /* ÿßŸÑÿ∑ÿßŸàŸÑÿ© */
        .board-tile { width: 60px; height: 30px; flex-direction: row; }
        .board-tile .line { width: 2px; height: 90%; margin: auto 2px; }
        .board-tile .pip-container { width: 29px; height: 30px; } .board-tile .pip { width: 5px; height: 5px; margin: auto; }

        /* ŸÖŸÜÿßÿ∑ŸÇ ÿßŸÑÿ•ÿ≥ŸÇÿßÿ∑ */
        .drop-zone {
            position: absolute; border: 2px dashed var(--gold); background-color: var(--drop-zone);
            border-radius: 5px; animation: pulse 1s infinite; cursor: pointer;
            display: flex; justify-content: center; align-items: center; color: white; font-weight: bold;
            width: 60px; height: 30px; z-index: 15;
        }
        .drop-zone:hover { background-color: var(--gold); color: black; }
        .dz-v { width: 30px; height: 60px; } 

        @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

        #game-interface { width: 100%; height: 100%; display: flex; flex-direction: column; overflow: hidden; }
        
        #table-surface {
            flex: 1; margin: 5px; border-radius: 15px; border: 2px solid #334155;
            background: rgba(15, 23, 42, 0.5); 
            position: relative; overflow: hidden;
            box-shadow: inset 0 0 50px black;
        }
        
        #game-board { 
            position: absolute; top: 50%; left: 50%; 
            width: 0; height: 0; transition: transform 0.3s ease-out;
        }

        /* ÿ™ÿπÿØŸäŸÑ ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑŸÑÿßÿπÿ®: ÿ≤ŸäÿßÿØÿ© ÿßŸÑÿ≠ÿ¥Ÿà ÿßŸÑÿ≥ŸÅŸÑŸä */
        #my-area { 
            height: 130px; /* ÿ≤ŸäÿßÿØÿ© ÿßŸÑÿßÿ±ÿ™ŸÅÿßÿπ */
            background: rgba(0,0,0,0.85); display: flex; flex-direction: column; align-items: center; justify-content: flex-end; 
            position: relative; border-top: 1px solid #444; padding-bottom: 25px; z-index: 200;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.8);
        }
        #my-hand { 
            display: flex; overflow-x: auto; padding: 10px; 
            width: 100%; align-items: flex-end; justify-content: center; height: 85px; 
        }
        #draw-btn { position: absolute; top: -50px; background: var(--gold); color: black; z-index: 50; box-shadow: 0 0 10px var(--gold); }

        .player-pos {
            position: absolute; background: rgba(30, 41, 59, 0.95); padding: 4px 8px;
            border-radius: 8px; display: flex; flex-direction: column; align-items: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); min-width: 70px; z-index: 20; font-size: 0.8rem;
        }
        .player-pos.active-turn { border: 1px solid var(--gold); box-shadow: 0 0 10px var(--gold); }
        .pos-top { top: 10px; left: 50%; transform: translateX(-50%); }
        .pos-left { top: 50%; left: 10px; transform: translateY(-50%); }
        .pos-right { top: 50%; right: 10px; transform: translateY(-50%); }
        .timer-bar { height: 2px; background: var(--danger); width: 100%; margin-top: 3px; transition: width 0.5s linear; }

        #toast, #screen-winner, #chat-box, #chat-icon { z-index: 999; }
        #toast {
            position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: white; padding: 10px 20px; border-radius: 20px;
            border: 1px solid var(--gold); opacity: 0; transition: opacity 0.3s; pointer-events: none;
        }
        #chat-icon { position: fixed; bottom: 150px; left: 20px; width: 40px; height: 40px; background: var(--accent-color); border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; }
        #chat-badge { position: absolute; top: -5px; right: -5px; background: red; color: white; width: 15px; height: 15px; border-radius: 50%; font-size: 10px; display: flex; justify-content: center; align-items: center; }
        #chat-box { position: fixed; bottom: 200px; left: 20px; width: 250px; height: 250px; background: var(--glass-bg); border-radius: 10px; display: flex; flex-direction: column; }
        #chat-msgs { flex: 1; overflow-y: auto; padding: 10px; }
        .msg { background: rgba(255,255,255,0.1); padding: 5px; margin: 3px 0; border-radius: 5px; font-size: 12px; text-align: right; }
        .msg.mine { background: rgba(59, 130, 246, 0.4); align-self: flex-end; }
    </style>
</head>
<body>

    <h1 class="game-title">HEKA ULTRA</h1>
    <div id="toast"></div>

    <div class="container">
        <div id="screen-login" class="screen">
            <h2>ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿØÿÆŸàŸÑ</h2>
            <input type="text" id="username" placeholder="ÿßÿ≥ŸÖŸÉ">
            <button onclick="saveName()">ÿØÿÆŸàŸÑ</button>
        </div>

        <div id="screen-menu" class="screen hidden">
            <h3 id="welcome-msg"></h3>
            <button onclick="creategame()" style="background:#10b981; width:80%">ÿ•ŸÜÿ¥ÿßÿ° ÿ∫ÿ±ŸÅÿ©</button>
            <br>
            <input type="text" id="code-input" placeholder="ŸÉŸàÿØ ÿßŸÑÿ∫ÿ±ŸÅÿ©" style="width:100px">
            <button onclick="joingame()">ÿØÿÆŸàŸÑ</button>
        </div>

        <div id="screen-lobby" class="screen hidden">
            <h2>ÿ∫ÿ±ŸÅÿ©: <span id="lobby-code" style="color:var(--gold)"></span></h2>
            <ul id="lobby-list" style="list-style:none; padding:0; text-align:right"></ul>
            <button id="start-btn" class="hidden" onclick="startGame()">ÿßÿ®ÿØÿ£ ÿßŸÑÿ¨ŸàŸÑÿ©</button>
            <button onclick="leavegame()" style="background:var(--danger)">ÿÆÿ±Ÿàÿ¨</button>
        </div>

        <div id="screen-game" class="hidden" style="width:100%; height:100%">
            <div id="game-interface">
                <div style="padding:10px; display:flex; justify-content:space-between; align-items:center; z-index:30;">
                    <button onclick="leavegame()" style="background:var(--danger); font-size:12px; padding:5px 10px">ÿßŸÜÿ≥ÿ≠ÿßÿ®</button>
                    <span style="color:#aaa; font-size:12px">Room: <span id="game-code"></span></span>
                </div>

                <div id="table-surface" onclick="cancelSelection(event)">
                    <div id="opponents"></div> 
                    <div id="game-board"></div> 
                </div>

                <div id="my-area">
                    <button id="draw-btn" class="hidden">ÿ≥ÿ≠ÿ®</button>
                    <div id="my-score-display" style="position:absolute; top:-25px; left:10px; color:var(--gold); font-weight:bold; font-size:0.9rem;">ŸÜŸÇÿßÿ∑ŸÉ: 0</div>
                    <div id="my-hand"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="screen-winner" class="screen hidden" style="position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); border:2px solid var(--gold);">
        <h1 style="color:var(--gold); font-size:2rem;">üèÜ CHAMPION üèÜ</h1>
        <h2 id="winner-name"></h2>
        <button onclick="leavegame()">ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©</button>
    </div>

    <div id="chat-icon" class="hidden" onclick="toggleChat()"><div id="chat-badge" class="hidden">0</div>üí¨</div>
    <div id="chat-box" class="hidden">
        <div style="padding:5px; background:rgba(0,0,0,0.3); color:white; display:flex; justify-content:space-between;"><span>Chat</span><span onclick="toggleChat()" style="cursor:pointer">x</span></div>
        <div id="chat-msgs"></div>
        <div style="display:flex; padding:5px;"><input id="chat-in" style="flex:1; margin:0"><button onclick="sendMsg()" style="margin:0 5px">></button></div>
    </div>

<script>
    const firebaseConfig = { apiKey: "AIzaSyCp9_P3K__Sr76iKgaVG1iD4NluUqPtni4", authDomain: "heka-codenames.firebaseapp.com", projectId: "heka-codenames", storageBucket: "heka-domino.firebasestorage.app", messagingSenderId: "901713932504", appId: "1:901713932504:web:b6710ddf537cd3c7c4e7ad" };
    if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    let myName="", myId="", currentgame="", isHost=false;
    let gameData={}, chatOpen=false, timerInt=null;
    let selectedIdx = -1;

    window.onload = () => {
        if(localStorage.getItem('heka_ultra_name')) {
            document.getElementById('username').value = localStorage.getItem('heka_ultra_name');
            saveName();
        }
    };

    function show(id) {
        document.querySelectorAll('.screen, #screen-game').forEach(e => e.classList.add('hidden'));
        document.getElementById(id).classList.remove('hidden');
    }
    function saveName() {
        myName = document.getElementById('username').value.trim();
        if(!myName) return;
        localStorage.setItem('heka_ultra_name', myName);
        document.getElementById('welcome-msg').innerText = `Ÿäÿß ŸáŸÑÿß ÿ®ŸÄ ${myName}`;
        show('screen-menu');
    }
    function showToast(msg) {
        const t = document.getElementById('toast');
        t.innerText = msg; t.style.opacity=1;
        setTimeout(()=>t.style.opacity=0, 2000);
    }
    function creategame() {
        const code = Math.floor(1000+Math.random()*9000).toString();
        myId = Date.now().toString();
        db.ref('games/'+code).set({
            status: 'waiting', host: myId, roundCount: 0,
            players: { [myId]: { name: myName, score: 0, hand:[], count:0, isBot:false } }
        }).then(()=>entergame(code, true));
    }
    function joingame() {
        const code = document.getElementById('code-input').value.trim();
        if(!code) return;
        myId = Date.now().toString();
        db.ref('games/'+code).once('value', s => {
            if(!s.exists()) return alert("ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©");
            if(s.val().status !== 'waiting') return alert("ÿ®ÿØÿ£ÿ™ ÿ®ÿßŸÑŸÅÿπŸÑ");
            if(Object.keys(s.val().players||{}).length >=4) return alert("ŸÖŸÖÿ™ŸÑÿ¶ÿ©");
            db.ref(`games/${code}/players/${myId}`).set({ name: myName, score: 0, hand:[], count:0, isBot:false })
            .then(()=>entergame(code, false));
        });
    }
    function entergame(code, host) {
        currentgame = code; isHost = host;
        document.getElementById('lobby-code').innerText = code;
        document.getElementById('game-code').innerText = code;
        show('screen-lobby');
        if(isHost) document.getElementById('start-btn').classList.remove('hidden');
        document.getElementById('chat-icon').classList.remove('hidden');
        db.ref(`games/${code}/players/${myId}`).onDisconnect().update({ isBot: true });
        listen();
    }
    function leavegame() {
        if(currentgame && myId) db.ref(`games/${currentgame}/players/${myId}`).update({ isBot: true });
        location.reload();
    }
    function listen() {
        db.ref(`games/${currentgame}`).on('value', s => {
            const d = s.val();
            if(!d) return location.reload();
            gameData = d;
            if(d.status === 'waiting') updateLobby(d.players);
            else if(d.status === 'playing') {
                if(document.getElementById('screen-game').classList.contains('hidden')) show('screen-game');
                updateGame(d);
                checkTimer(d);
            } 
            else if (d.status === 'finished') {
                showToast(`ÿßŸÑŸÅÿßÿ¶ÿ≤: ${d.roundWinnerName}`);
                if(isHost) setTimeout(startGame, 3000);
            }
            else if (d.status === 'match_over') {
                document.getElementById('winner-name').innerText = d.matchWinnerName;
                document.getElementById('screen-winner').classList.remove('hidden');
            }
            updateChat(d.chat);
        });
    }
    function updateLobby(players) {
        const list = document.getElementById('lobby-list'); list.innerHTML = "";
        Object.values(players||{}).forEach(p => list.innerHTML += `<li>${p.name} ${p.isBot?'ü§ñ':''} - üèÜ${p.score}</li>`);
    }

    function startGame() {
        const pIds = Object.keys(gameData.players);
        if(pIds.length < 2) return alert("2 ŸÑÿßÿπÿ®ŸäŸÜ ÿπ ÿßŸÑÿ£ŸÇŸÑ");
        pIds.sort();
        let tiles = [];
        for(let i=0; i<=6; i++) for(let j=i; j<=6; j++) tiles.push({a:i, b:j});
        let handSize = 7;
        if(pIds.length === 3) { tiles = tiles.filter(t => !(t.a===0 && t.b===0)); handSize = 9; }
        tiles.sort(()=>Math.random()-0.5);
        const updates = { status: 'playing', board: [], stock: tiles, playerOrder: pIds };
        let startTurnIndex = 0, hasSixSix = -1;
        pIds.forEach((id, idx) => {
            const hand = tiles.splice(0, handSize);
            updates[`players/${id}/hand`] = hand;
            updates[`players/${id}/count`] = handSize;
            if(gameData.roundCount === 0 && hand.some(t => t.a===6 && t.b===6)) hasSixSix = idx;
        });
        if(gameData.roundCount === 0) startTurnIndex = (hasSixSix !== -1) ? hasSixSix : 0;
        else if(gameData.lastWinnerId) { const idx = pIds.indexOf(gameData.lastWinnerId); startTurnIndex = (idx !== -1) ? idx : 0; }
        
        updates['turnIndex'] = startTurnIndex;
        updates['turnStartTime'] = firebase.database.ServerValue.TIMESTAMP;
        updates['roundCount'] = (gameData.roundCount || 0) + 1;
        db.ref('games/'+currentgame).update(updates);
    }

    function updateGame(data) {
        const pIds = data.playerOrder;
        const myIdx = pIds.indexOf(myId);
        const turnId = pIds[data.turnIndex];
        
        const oppDiv = document.getElementById('opponents'); oppDiv.innerHTML = "";
        const count = pIds.length;
        for(let i=1; i<count; i++) {
            const tIdx = (myIdx + i) % count; const tId = pIds[tIdx]; const p = data.players[tId];
            let cls = "pos-top";
            if(count===3) cls = (i===1) ? "pos-right" : "pos-left";
            if(count===4) cls = (i===1) ? "pos-right" : (i===2 ? "pos-top" : "pos-left");
            const isTurn = (turnId === tId);
            oppDiv.innerHTML += `<div class="player-pos ${cls} ${isTurn?'active-turn':''}">
                <div style="font-size:16px">üë§</div><div>${p.name} ${p.isBot?'ü§ñ':''}</div>
                <div style="color:#aaa">${p.count} üÄÑ</div><div class="p-score">${p.score}</div>
                ${isTurn ? '<div class="timer-bar" id="tbar-'+tId+'"></div>' : ''}</div>`;
        }

        document.getElementById('my-score-display').innerText = `ŸÜŸÇÿßÿ∑ŸÉ: ${data.players[myId].score}`;
        const myArea = document.getElementById('my-area');
        if(turnId === myId) {
            myArea.style.borderTop = "3px solid var(--gold)";
            if(!document.getElementById('my-timer')) myArea.insertAdjacentHTML('afterbegin', `<div id="my-timer" class="timer-bar" style="position:absolute; top:0; width:100%"></div>`);
            checkAutoPass(data);
        } else {
            myArea.style.borderTop = "1px solid #444";
            if(document.getElementById('my-timer')) document.getElementById('my-timer').remove();
            selectedIdx = -1;
        }

        renderBoard(data.board||[]);
        if(selectedIdx === -1) renderHand(data.players[myId].hand||[]);
        
        const btn = document.getElementById('draw-btn'); btn.classList.add('hidden');
        if(turnId === myId && count === 2 && !hasMove(data.players[myId].hand, data.board)) {
            if(data.stock && data.stock.length > 0) { btn.classList.remove('hidden'); btn.onclick = drawTile; }
        }
    }

    // --- REVISED SNAKE LAYOUT SYSTEM ---
    const TILE_W = 60;
    const TILE_H = 30;
    const GAP = 2; 
    const ROW_LIMIT = 4; // Max tiles per horizontal row

    function calculateSnakePositions(board) {
        if(!board || board.length === 0) return [];
        
        const positions = Array(board.length).fill(null);
        let cx = 0, cy = 0;
        let direction = 1; // 1 = Right, -1 = Left
        let tilesInRow = 0;
        
        // Loop through board
        for(let i=0; i<board.length; i++) {
            const t = board[i];
            const isDouble = (t.a === t.b);
            
            // Logic: Check if we need to turn *BEFORE* placing this tile
            // A turn happens if we hit the limit
            let isCorner = false;

            if (tilesInRow >= ROW_LIMIT) {
                isCorner = true;
                // Place this tile vertically UNDER the previous one
                cy += (TILE_W/2 + TILE_H/2 + GAP); // Move down
                // X remains the same as previous tile to form the elbow
                
                // Reset row counter
                tilesInRow = 0;
                // Flip direction for NEXT tiles
                direction *= -1;
            } else {
                // Horizontal Placement
                if(i > 0) {
                   // Add width of previous + width of current
                   let prevT = board[i-1];
                   let prevIsDouble = (prevT.a === prevT.b);
                   let prevIsCorner = (positions[i-1].isCorner);
                   
                   let prevLen = prevIsDouble ? TILE_H : TILE_W;
                   let currLen = isDouble ? TILE_H : TILE_W;
                   
                   // If previous was a corner, we are moving sideways from it
                   if (prevIsCorner) {
                       // The corner tile was vertical. We move sideways from it.
                       // Distance is half height of corner + gap + half width of current
                       // Actually corner tile is usually rendered vertically (height=60)
                       // So we move sideways:
                       let dist = (TILE_H/2 + currLen/2 + GAP); 
                       // Wait, if corner is Double, it's Horizontal width (30).. Logic gets complex.
                       // Simplified:
                       // Previous tile X is anchor.
                       // We just step X.
                       let step = (prevLen/2 + currLen/2 + GAP);
                       if(positions[i-1].isCorner) step = (TILE_W/2 + currLen/2 + GAP); // Corner is always vertical roughly
                       cx += step * direction;
                   } else {
                       let step = (prevLen/2 + currLen/2 + GAP);
                       cx += step * direction;
                   }
                }
            }

            // Determine rotation
            let rot = 0;
            if(isCorner) {
                // Corner tiles are vertical
                rot = isDouble ? 0 : 90; // Double 0 (horiz look vertical), Normal 90
            } else {
                // Normal row tiles
                rot = isDouble ? 90 : (direction === 1 ? 0 : 180);
            }

            positions[i] = { x: cx, y: cy, angle: rot, dir: direction, isCorner: isCorner };
            if(!isCorner) tilesInRow++;
        }
        
        // Center the board
        if(positions.length > 0) {
            let minX = Math.min(...positions.map(p=>p.x)), maxX = Math.max(...positions.map(p=>p.x));
            let minY = Math.min(...positions.map(p=>p.y)), maxY = Math.max(...positions.map(p=>p.y));
            let midX = (minX + maxX) / 2;
            let midY = (minY + maxY) / 2;
            
            positions.forEach(p => { p.x -= midX; p.y -= midY; });
            
            const boardDiv = document.getElementById('game-board');
            let scale = 1;
            if(positions.length > 8) scale = 0.8;
            if(positions.length > 15) scale = 0.65;
            if(positions.length > 22) scale = 0.5;
            boardDiv.style.transform = `translate(-50%, -50%) scale(${scale})`;
        }
        return positions;
    }

    function renderBoard(board) {
        const d = document.getElementById('game-board');
        d.innerHTML = "";
        const coords = calculateSnakePositions(board);
        
        // We need to track connectivity to orient faces
        // Board is [0]..[N]. 0 is start. N is end.
        // We assume 0 is the "Left/Start" anchor.
        
        let connector = -1; // The value that the current tile must match
        
        // Setup first tile
        if(board.length > 0) {
            // First tile orientation depends on second tile
            if(board.length > 1) {
                // Check connectivity between 0 and 1
                const t0 = board[0];
                const t1 = board[1];
                if(t0.a === t1.a || t0.a === t1.b) {
                    connector = t0.a; // t0.a connects to t1. So t0.b is the loose start end.
                } else {
                    connector = t0.b; // t0.b connects.
                }
            } else {
                connector = board[0].b; // Default
            }
        }

        board.forEach((t, i) => {
            const pos = coords[i];
            const isDouble = t.a === t.b;
            const cls = isDouble ? 'board-tile double' : 'board-tile';
            
            let v1 = t.a, v2 = t.b; // v1 is "Left/Top", v2 is "Right/Bottom" visually in DOM order
            
            // Logic to swap v1/v2 based on connector and direction
            // We want the 'matching' side to be closer to previous tile
            
            if(i === 0) {
                // First tile: The connector is the side facing NEXT tile
                // If moving Right: [Start|Conn] -> v2 should be connector
                // If moving Left:  [Conn|Start] -> v1 should be connector
                // But wait, connector is defined above as the connecting val.
                let looseEnd = (t.a === connector) ? t.b : t.a;
                
                if (pos.dir === 1) { // Right
                     v1 = looseEnd; v2 = connector;
                } else { // Left
                     v1 = connector; v2 = looseEnd;
                }
            } else {
                // Subsequent tiles: One side MUST match 'connector' (from prev tile)
                // New connector for next tile becomes the other side
                let matchVal = (t.a === connector) ? t.a : t.b;
                let nextConn = (t.a === connector) ? t.b : t.a;
                
                // Render orientation
                if(pos.isCorner) {
                     // Vertical down. Top should be matchVal
                     // DOM order [Top, Bottom]
                     v1 = matchVal; v2 = nextConn;
                } else if (pos.dir === 1) { 
                     // Moving Right: [Match|Next]
                     v1 = matchVal; v2 = nextConn;
                } else { 
                     // Moving Left: [Next|Match]
                     v1 = nextConn; v2 = matchVal;
                }
                
                connector = nextConn; // Update for next iteration
            }

            if(isDouble) { v1 = t.a; v2 = t.b; }

            const tileHtml = `
                <div class="domino ${cls}" 
                     style="left: ${pos.x}px; top: ${pos.y}px; transform: translate(-50%, -50%) rotate(${pos.angle}deg);">
                    <div class="pip-container">${getPips(v1)}</div>
                    <div class="line"></div>
                    <div class="pip-container">${getPips(v2)}</div>
                </div>`;
            d.innerHTML += tileHtml;
        });
        return coords;
    }

    // Ghost Rendering
    function renderBoardWithGhosts(board, tile) {
        const coords = renderBoard(board);
        const div = document.getElementById('game-board');

        if(board.length === 0) {
             div.innerHTML = `<div class="drop-zone dz-v" style="left:0; top:0; transform: translate(-50%, -50%)" onclick="commitMove('any')">+</div>`;
             return;
        }

        const canLeft = hasMatch(tile, board[0]); 
        const canRight = hasMatch(tile, board[board.length-1]);

        // Right Ghost
        if(canRight) {
            const last = coords[coords.length-1];
            let gx = last.x, gy = last.y;
            let rot = 0;
            // Guess next position
            let isCornerNext = ((board.length) % ROW_LIMIT === 0); // Modulo logic approx
            // Better: use last pos info
            if(board.length % ROW_LIMIT === 0) {
                 gy += (TILE_W/2 + TILE_H/2 + GAP);
                 rot = 90;
            } else {
                 let dir = last.dir;
                 let lastIsDouble = (board[board.length-1].a === board[board.length-1].b);
                 let nextIsDouble = (tile.a === tile.b);
                 if(last.isCorner) { // If last was corner, we move sideways
                     gx += (TILE_W/2 + TILE_W/2 + GAP) * dir;
                 } else {
                     let step = (TILE_W + GAP); // Approx
                     gx += step * dir;
                 }
                 if(nextIsDouble) rot = 90;
                 else if(dir === -1) rot = 180;
            }
            
            const cls = (tile.a === tile.b) ? 'dz-v' : 'drop-zone';
            div.insertAdjacentHTML('beforeend', `<div class="drop-zone ${cls}" style="left:${gx}px; top:${gy}px; transform: translate(-50%, -50%) rotate(${rot}deg)" onclick="commitMove('right')">+</div>`);
        }
        
        // Left Ghost
        if(canLeft) {
            const first = coords[0];
            // Just place left of first
            let gx = first.x - (TILE_W + GAP);
            let gy = first.y; 
            div.insertAdjacentHTML('beforeend', `<div class="drop-zone" style="left:${gx}px; top:${gy}px; transform: translate(-50%, -50%)" onclick="commitMove('left')">+</div>`);
        }
    }
    
    function hasMatch(tile, target) { return (tile.a === target.a || tile.b === target.a || tile.a === target.b || tile.b === target.b); }
    function selectTile(idx) {
        const pIds = gameData.playerOrder;
        if(pIds[gameData.turnIndex] !== myId) return;
        const hand = gameData.players[myId].hand;
        const board = gameData.board || [];
        const tile = hand[idx];
        if(selectedIdx === idx) { cancelSelection(); return; }
        if(board.length === 0 && gameData.roundCount === 1) {
            const has66 = hand.findIndex(t => t.a===6 && t.b===6);
            if(has66 !== -1 && (tile.a!==6 || tile.b!==6)) { showToast("ŸÑÿßÿ≤ŸÖ 6-6!"); return; }
        }
        selectedIdx = idx;
        renderHand(hand);
        renderBoardWithGhosts(board, tile);
    }
    function cancelSelection(e) {
        if(e && e.target.closest('.domino')) return;
        selectedIdx = -1;
        renderHand(gameData.players[myId].hand);
        renderBoard(gameData.board || []);
    }
    function commitMove(side) {
        if(selectedIdx === -1) return;
        const hand = gameData.players[myId].hand;
        const tile = hand[selectedIdx];
        let board = [...(gameData.board || [])];
        let newTile = {...tile};
        if(side === 'any' || board.length === 0) { board.push(newTile); } 
        else if (side === 'left') { board.unshift(newTile); } 
        else { board.push(newTile); }
        hand.splice(selectedIdx, 1);
        selectedIdx = -1;
        if(hand.length === 0) handleRoundWin(myId, board);
        else nextTurn(board, hand);
    }
    function checkAutoPass(data) {
        const hand = data.players[myId].hand || [];
        const board = data.board || [];
        const stock = data.stock || [];
        const canDraw = (Object.keys(data.players).length === 2 && stock.length > 0);
        if(!hasMove(hand, board) && !canDraw) {
            showToast("üö´ ŸÑÿß ŸäŸàÿ¨ÿØ ŸÑÿπÿ® - Pass");
            setTimeout(() => {
                const next = (data.turnIndex + 1) % data.playerOrder.length;
                db.ref('games/'+currentgame).update({ turnIndex: next, turnStartTime: firebase.database.ServerValue.TIMESTAMP });
            }, 1500);
        }
    }
    function checkTimer(data) {
        if(timerInt) clearInterval(timerInt);
        const startTime = data.turnStartTime || Date.now();
        const turnId = data.playerOrder[data.turnIndex];
        const playerObj = data.players[turnId];
        if(playerObj.isBot) { if(isHost) setTimeout(() => autoBot(turnId), 1000); return; }
        timerInt = setInterval(() => {
            const elapsed = (Date.now() - startTime) / 1000;
            const remaining = 30 - elapsed;
            const bar = document.getElementById(turnId===myId ? 'my-timer' : 'tbar-'+turnId);
            if(bar) bar.style.width = Math.max(0, (remaining/30)*100) + "%";
            if(remaining <= 0) { clearInterval(timerInt); if(turnId === myId) autoBot(myId); else if(isHost && playerObj.isBot) autoBot(turnId); }
        }, 1000);
    }
    function nextTurn(board, hand) {
        const next = (gameData.turnIndex + 1) % gameData.playerOrder.length;
        db.ref('games/'+currentgame).update({
            board: board, turnIndex: next, turnStartTime: firebase.database.ServerValue.TIMESTAMP,
            [`players/${myId}/hand`]: hand, [`players/${myId}/count`]: hand.length
        });
    }
    function handleRoundWin(winnerId, board) {
        let total = 0;
        Object.keys(gameData.players).forEach(id => { if(id !== winnerId) (gameData.players[id].hand||[]).forEach(t => total += (t.a + t.b)); });
        const newScore = (gameData.players[winnerId].score || 0) + total;
        const up = { [`players/${winnerId}/score`]: newScore, status: 'finished', lastWinnerId: winnerId, roundWinnerName: gameData.players[winnerId].name, board: board, [`players/${winnerId}/hand`]: [] };
        if(newScore >= 101) { up.status = 'match_over'; up.matchWinnerName = gameData.players[winnerId].name; }
        db.ref('games/'+currentgame).update(up);
    }
    function drawTile() {
        let stock = gameData.stock || [];
        if(stock.length === 0) return;
        const t = stock.pop();
        const hand = gameData.players[myId].hand; hand.push(t);
        db.ref('games/'+currentgame).update({ stock: stock, [`players/${myId}/hand`]: hand, [`players/${myId}/count`]: hand.length });
    }
    function hasMove(hand, board) {
        if(!board || board.length===0) return true;
        const l = board[0].a, r = board[board.length-1].b;
        return hand.some(t => t.a===l || t.b===l || t.a===r || t.b===r);
    }
    function renderHand(hand) {
        const d = document.getElementById('my-hand'); d.innerHTML = "";
        hand.forEach((t, i) => {
            const isSel = (i === selectedIdx) ? 'selected' : '';
            d.innerHTML += `<div class="domino hand-tile ${isSel}" onclick="selectTile(${i})"><div class="pip-container">${getPips(t.a)}</div><div class="line"></div><div class="pip-container">${getPips(t.b)}</div></div>`;
        });
    }
    function getPips(n) {
        const m={0:[], 1:['p1'],2:['p2-1','p2-2'],3:['p3-1','p3-2','p3-3'],4:['p4-1','p4-2','p4-3','p4-4'],5:['p5-1','p5-2','p5-3','p5-4','p5-5'],6:['p6-1','p6-2','p6-3','p6-4','p6-5','p6-6']};
        return (m[n]||[]).map(c=>`<div class="pip ${c}"></div>`).join('');
    }
    function autoBot(pId) {
        const p = gameData.players[pId];
        const hand = p.hand || [];
        const board = gameData.board || [];
        let playIdx=-1, side='right';
        if(board.length===0) { playIdx=0; side='any'; }
        else {
            const l=board[0].a, r=board[board.length-1].b;
            for(let i=0; i<hand.length; i++) {
                if(hand[i].a===r || hand[i].b===r) { playIdx=i; side='right'; break; }
                if(hand[i].a===l || hand[i].b===l) { playIdx=i; side='left'; break; }
            }
        }
        if(playIdx !== -1) {
            const tile = hand[playIdx]; let newTile = {...tile}; let newBoard = [...board];
            if(side === 'left') { if(newTile.a===board[0].a) newTile={a:tile.b,b:tile.a}; newBoard.unshift(newTile); }
            else { const end=board.length?board[board.length-1].b:-1; if(board.length && newTile.b===end) newTile={a:tile.b,b:tile.a}; newBoard.push(newTile); }
            hand.splice(playIdx, 1);
            const next = (gameData.turnIndex + 1) % gameData.playerOrder.length;
            const up = { board: newBoard, turnIndex: next, turnStartTime: firebase.database.ServerValue.TIMESTAMP, [`players/${pId}/hand`]: hand, [`players/${pId}/count`]: hand.length };
            if(hand.length===0) {
                up.status='finished'; up.roundWinnerName=p.name; up.lastWinnerId=pId;
                let total=0; Object.keys(gameData.players).forEach(oid=>{ if(oid!==pId) (gameData.players[oid].hand||[]).forEach(t=>total+=t.a+t.b) });
                up[`players/${pId}/score`] = (p.score||0)+total;
            }
            db.ref('games/'+currentgame).update(up);
        } else {
            if(Object.keys(gameData.players).length===2 && (gameData.stock||[]).length>0) {
                const stock = gameData.stock; const t = stock.pop(); hand.push(t);
                db.ref('games/'+currentgame).update({ stock:stock, [`players/${pId}/hand`]:hand, [`players/${pId}/count`]:hand.length });
            } else {
                const next = (gameData.turnIndex + 1) % gameData.playerOrder.length;
                db.ref('games/'+currentgame).update({ turnIndex: next, turnStartTime: firebase.database.ServerValue.TIMESTAMP });
            }
        }
    }
    function toggleChat(){ chatOpen=!chatOpen; document.getElementById('chat-box').classList.toggle('hidden'); document.getElementById('chat-badge').classList.add('hidden'); }
    function sendMsg(){ const i=document.getElementById('chat-in'); if(i.value) db.ref(`games/${currentgame}/chat`).push({n:myName, t:i.value}); i.value=""; }
    function updateChat(c){ const b=document.getElementById('chat-msgs'); b.innerHTML=Object.values(c||{}).map(m=>`<div class="msg ${m.n===myName?'mine':''}"><b>${m.n}:</b> ${m.t}</div>`).join(''); if(!chatOpen && c) document.getElementById('chat-badge').classList.remove('hidden'); }
</script>
</body>
</html>
