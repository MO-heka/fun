<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DOMINO HEKA ULTRA</title>
    <link href="https://fonts.googleapis.com/css2?family=Righteous&family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    
    <style>
        :root { 
            --bg-color: #0f172a; 
            --glass-bg: rgba(30, 41, 59, 0.95);
            --domino-white: #f1f2f6;
            --domino-black: #1e272e;
            --accent-color: #3b82f6; 
            --gold: #fbbf24;
            --danger: #ef4444;
            --drop-zone: rgba(251, 191, 36, 0.5);
        }

        /* ========== CSS FIX FROM USER ========== */
        body { 
            font-family: 'Cairo', sans-serif; 
            background-color: var(--bg-color);
            background-image: radial-gradient(#1e293b 15%, transparent 16%), radial-gradient(#1e293b 15%, transparent 16%);
            background-size: 60px 60px;
            color: #e2e8f0; margin: 0; height: 100vh;
            display: flex; flex-direction: column; user-select: none;
            touch-action: none;
            overflow: hidden; /* Fix */
        }

        /* Ÿàÿßÿ¨Ÿáÿ© ÿßŸÑŸÑÿπÿ® */
        #game-interface { width: 100%; height: 100%; position: relative; }
        
        /* ÿ≥ÿ∑ÿ≠ ÿßŸÑÿ∑ÿßŸàŸÑÿ© */
        #table-surface {
            position: absolute; top: 0; left: 0; right: 0; bottom: 130px; 
            overflow: hidden; 
            background: rgba(15, 23, 42, 0.3);
            display: flex; justify-content: center; align-items: center;
        }

        /* ÿ≠ÿßŸàŸäÿ© ÿßŸÑŸÉÿ±Ÿàÿ™ ŸÅŸä ÿßŸÑÿ∑ÿßŸàŸÑÿ© */
        #game-board { 
            position: absolute; 
            top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            transition: all 0.5s ease;
            width: 0; height: 0; 
            transform-origin: center center; /* Fix */
        }

        /* ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑŸÑÿßÿπÿ® (ÿßŸÑŸäÿØ) */
        #my-area { 
            position: fixed; bottom: 0; left: 0; width: 100%; height: 120px;
            background: rgba(15, 23, 42, 0.95); 
            border-top: 2px solid var(--gold);
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            box-shadow: 0 -5px 20px rgba(0,0,0,0.8);
            padding-bottom: 10px;
            z-index: 999; /* Fix */
            overflow: visible; /* Fix */
        }

        #my-hand { 
            display: flex; overflow-x: auto; padding: 10px; width: 100%; 
            align-items: center; justify-content: center; height: 100%; 
        }

        /* ÿßŸÑÿØŸàŸÖŸäŸÜŸà */
        .domino { 
            background-color: var(--domino-white); border-radius: 4px; box-shadow: 3px 3px 0px #333; 
            display: flex; cursor: pointer; position: absolute; 
            transition: all 0.3s ease; transform-origin: center center;
            border: 1px solid #999;
            box-sizing: border-box;
        }
        .pip-container { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); padding: 2px; width: 100%; height: 100%; }
        .pip { background-color: var(--domino-black); border-radius: 50%; width: 100%; height: 100%; box-shadow: inset 0 1px 1px rgba(0,0,0,0.5); }
        .line { background-color: #999; }

        /* ÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑŸÜŸÇÿßÿ∑ */
        .p1 { grid-area: 2 / 2; } .p2-1 { grid-area: 1 / 3; } .p2-2 { grid-area: 3 / 1; }
        .p3-1 { grid-area: 1 / 3; } .p3-2 { grid-area: 2 / 2; } .p3-3 { grid-area: 3 / 1; }
        .p4-1 { grid-area: 1 / 1; } .p4-2 { grid-area: 1 / 3; } .p4-3 { grid-area: 3 / 1; } .p4-4 { grid-area: 3 / 3; }
        .p5-1 { grid-area: 1 / 1; } .p5-2 { grid-area: 1 / 3; } .p5-3 { grid-area: 2 / 2; } .p5-4 { grid-area: 3 / 1; } .p5-5 { grid-area: 3 / 3; }
        .p6-1 { grid-area: 1 / 1; } .p6-2 { grid-area: 1 / 3; } .p6-3 { grid-area: 2 / 1; } .p6-4 { grid-area: 2 / 3; } .p6-5 { grid-area: 3 / 1; } .p6-6 { grid-area: 3 / 3; }

        /* ŸÉÿ±Ÿàÿ™ ÿßŸÑŸäÿØ */
        .hand-tile { 
            position: relative; width: 40px; height: 80px; flex-direction: column; margin: 0 5px; z-index: 10; flex-shrink: 0; 
        }
        .hand-tile .line { height: 2px; width: 90%; margin: 2px auto; }
        .hand-tile .pip-container { width: 40px; height: 39px; } .hand-tile .pip { width: 7px; height: 7px; margin: auto; }
        .hand-tile.selected { transform: translateY(-40px) scale(1.1); box-shadow: 0 0 20px var(--gold); border: 2px solid var(--gold); z-index: 50; }

        /* ŸÉÿ±Ÿàÿ™ ÿßŸÑÿ∑ÿßŸàŸÑÿ© */
        .board-tile { width: 60px; height: 30px; flex-direction: row; }
        .board-tile .line { width: 2px; height: 90%; margin: auto 2px; }
        .board-tile .pip-container { width: 29px; height: 30px; } .board-tile .pip { width: 5px; height: 5px; margin: auto; }

        /* ŸÖŸÜÿßÿ∑ŸÇ ÿßŸÑÿ•ÿ≥ŸÇÿßÿ∑ (ÿßŸÑÿ£ÿ¥ÿ®ÿßÿ≠) */
        .drop-zone {
            position: absolute; border: 3px dashed var(--gold); background-color: var(--drop-zone);
            border-radius: 5px; animation: pulse 1s infinite; cursor: pointer;
            display: flex; justify-content: center; align-items: center; color: white; font-weight: bold;
            width: 60px; height: 30px; z-index: 100; font-size: 20px;
        }
        .drop-zone:hover { background-color: var(--gold); color: black; }
        @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

        /* ÿπŸÜÿßÿµÿ± ÿßŸÑÿ™ÿ≠ŸÉŸÖ */
        #draw-btn { position: absolute; top: -50px; left: 50%; transform: translateX(-50%); background: var(--gold); color: black; padding: 8px 20px; border-radius: 20px; font-weight: bold; box-shadow: 0 0 15px var(--gold); cursor: pointer; border: none; }
        .hidden { display: none !important; }

        /* ÿßŸÑÿ¥ÿßÿ¥ÿßÿ™ */
        .screen {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(30, 41, 59, 0.95); padding: 30px; border-radius: 20px; text-align: center;
            border: 1px solid rgba(255,255,255,0.1); width: 90%; max-width: 350px; z-index: 500;
        }
        h1.game-title {
            font-family: 'Righteous', cursive; font-size: 1.8rem; color: var(--gold);
            text-shadow: 0 0 15px rgba(251, 191, 36, 0.4); margin: 10px 0; text-align: center; pointer-events: none;
        }
        #screen-game h1.game-title { display: none; } 

        input { background: rgba(255,255,255,0.1); border: 1px solid #555; padding: 10px; color: white; border-radius: 8px; text-align: center; margin: 10px 0; width: 80%; }
        button { background: var(--accent-color); color: white; padding: 10px 20px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; margin: 5px; }

        .player-pos {
            position: absolute; background: rgba(0,0,0,0.8); padding: 5px 10px; border-radius: 10px; 
            color: white; font-size: 12px; border: 1px solid #555; z-index: 20;
        }
        .player-pos.active-turn { border-color: var(--gold); box-shadow: 0 0 10px var(--gold); }
        .pos-top { top: 10px; left: 50%; transform: translateX(-50%); }
        .pos-left { top: 40%; left: 10px; }
        .pos-right { top: 40%; right: 10px; }
        
        #toast { position: fixed; top: 20%; left: 50%; transform: translateX(-50%); background: #333; color: #fff; padding: 10px 20px; border-radius: 20px; z-index: 1000; opacity: 0; transition: opacity 0.3s; pointer-events: none; border: 1px solid var(--gold); }
    </style>
</head>
<body>

    <div id="toast"></div>

    <div id="screen-login" class="screen">
        <h2 style="color:var(--gold)">HEKA ULTRA</h2>
        <input type="text" id="username" placeholder="ÿßÿ≥ŸÖŸÉ">
        <button onclick="saveName()">ÿØÿÆŸàŸÑ</button>
    </div>

    <div id="screen-menu" class="screen hidden">
        <h3 id="welcome-msg" style="color:white"></h3>
        <button onclick="creategame()" style="background:#10b981; width:100%">ÿ•ŸÜÿ¥ÿßÿ° ÿ∫ÿ±ŸÅÿ©</button>
        <div style="margin:10px 0; color:#aaa">- ÿ£Ÿà -</div>
        <input type="text" id="code-input" placeholder="ŸÉŸàÿØ ÿßŸÑÿ∫ÿ±ŸÅÿ©">
        <button onclick="joingame()" style="width:100%">ÿßŸÜÿ∂ŸÖÿßŸÖ</button>
    </div>

    <div id="screen-lobby" class="screen hidden">
        <h2 style="color:var(--gold)">ÿ∫ÿ±ŸÅÿ©: <span id="lobby-code"></span></h2>
        <div id="lobby-list" style="text-align:right; margin:15px 0; min-height:50px;"></div>
        <button id="start-btn" class="hidden" onclick="startGame()">ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®</button>
        <button onclick="leavegame()" style="background:var(--danger)">ÿÆÿ±Ÿàÿ¨</button>
    </div>

    <div id="screen-game" class="hidden" style="width:100%; height:100%">
        <div id="game-interface">
            <div style="position:absolute; top:10px; left:10px; z-index:50;">
                <button onclick="leavegame()" style="background:var(--danger); font-size:10px; padding:5px 10px">ÿßŸÜÿ≥ÿ≠ÿßÿ®</button>
            </div>
            <div id="opponents"></div>
            <div id="table-surface" onclick="cancelSelection(event)">
                <div id="game-board"></div>
            </div>
            <div id="my-area">
                <button id="draw-btn" class="hidden" onclick="drawTile()">ÿ≥ÿ≠ÿ® ŸÉÿ±ÿ™</button>
                <div style="color:var(--gold); font-size:12px; margin-bottom:5px;">ŸÜŸÇÿßÿ∑ŸÉ: <span id="my-score">0</span></div>
                <div id="my-hand"></div>
            </div>
        </div>
    </div>

    <div id="screen-winner" class="screen hidden">
        <h1 style="color:var(--gold)">üèÜ ÿßŸÑŸÅÿßÿ¶ÿ≤ üèÜ</h1>
        <h2 id="winner-name"></h2>
        <button onclick="leavegame()">ÿßŸÑŸÇÿßÿ¶ŸÖÿ© ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ©</button>
    </div>

<script>
    const firebaseConfig = { apiKey: "AIzaSyCp9_P3K__Sr76iKgaVG1iD4NluUqPtni4", authDomain: "heka-codenames.firebaseapp.com", projectId: "heka-codenames", storageBucket: "heka-domino.firebasestorage.app", messagingSenderId: "901713932504", appId: "1:901713932504:web:b6710ddf537cd3c7c4e7ad" };
    if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    let myName="", myId="", currentgame="", isHost=false;
    let gameData={}, selectedIdx = -1;
    
    // ============================
    //    NEW VARIABLES FROM FIX
    // ============================
    const TILE_W = 60;
    const TILE_H = 30;
    const GAP = 6;
    const ROW_LIMIT = 7;

    window.onload = () => {
        if(localStorage.getItem('heka_user')) {
            document.getElementById('username').value = localStorage.getItem('heka_user');
            saveName();
        }
    };

    function saveName() {
        myName = document.getElementById('username').value.trim();
        if(!myName) return;
        localStorage.setItem('heka_user', myName);
        document.getElementById('welcome-msg').innerText = `ÿ£ŸáŸÑÿßŸã ${myName}`;
        show('screen-menu');
    }

    function show(id) {
        document.querySelectorAll('.screen, #screen-game').forEach(e => e.classList.add('hidden'));
        document.getElementById(id).classList.remove('hidden');
    }

    function showToast(msg) {
        const t = document.getElementById('toast');
        t.innerText = msg; t.style.opacity=1;
        setTimeout(()=>t.style.opacity=0, 2000);
    }

    function creategame() {
        const code = Math.floor(1000+Math.random()*9000).toString();
        myId = Date.now().toString();
        db.ref('games/'+code).set({
            status: 'waiting', host: myId, 
            players: { [myId]: { name: myName, score: 0, hand:[], count:0 } }
        }).then(()=>entergame(code, true));
    }

    function joingame() {
        const code = document.getElementById('code-input').value.trim();
        if(!code) return;
        myId = Date.now().toString();
        db.ref('games/'+code).once('value', s => {
            if(s.exists() && s.val().status === 'waiting') {
                db.ref(`games/${code}/players/${myId}`).set({ name: myName, score: 0, hand:[], count:0 })
                .then(()=>entergame(code, false));
            } else alert("ÿßŸÑÿ∫ÿ±ŸÅÿ© ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ÿ©");
        });
    }

    function entergame(code, host) {
        currentgame = code; isHost = host;
        document.getElementById('lobby-code').innerText = code;
        show('screen-lobby');
        if(isHost) document.getElementById('start-btn').classList.remove('hidden');
        listen();
    }

    function leavegame() {
        if(currentgame) db.ref(`games/${currentgame}/players/${myId}`).remove();
        location.reload();
    }

    function listen() {
        db.ref(`games/${currentgame}`).on('value', s => {
            const d = s.val();
            if(!d) return location.reload();
            gameData = d;
            
            if(d.status === 'waiting') {
                const list = document.getElementById('lobby-list'); list.innerHTML = "";
                Object.values(d.players||{}).forEach(p => list.innerHTML += `<div>üë§ ${p.name}</div>`);
            } else if(d.status === 'playing') {
                show('screen-game');
                renderGame(d);
            } else if(d.status === 'finished') {
                document.getElementById('winner-name').innerText = d.winnerName;
                show('screen-winner');
            }
        });
    }

    /* ============================
       START PLAYER WITH BIGGEST DOUBLE
    ============================ */
    function getStartingPlayer(pIds, players_snapshot){
        let best = { id:null, val:-1 };
        // Note: players_snapshot might be the raw object used in startGame, not gameData yet
        pIds.forEach(id => {
            let hand = players_snapshot[id].hand || [];
            hand.forEach(t => {
                if(t.a === t.b){
                    if(t.a > best.val){
                        best = { id:id, val:t.a };
                    }
                }
            });
        });
        return best.id;
    }

    /* ============================
       START GAME FIX
    ============================ */
    function startGame(){
        const pIds=Object.keys(gameData.players);
        if(pIds.length < 2) return alert("ÿßŸÜÿ™ÿ∏ÿ± ŸÑÿßÿπÿ®ŸäŸÜ");

        let tiles=[];
        for(let i=0;i<=6;i++)for(let j=i;j<=6;j++)tiles.push({a:i,b:j});
        tiles.sort(()=>Math.random()-0.5);

        let handSize=7;
        // Temporary object to hold new state
        let playersState = {}; 
        
        pIds.forEach(id=>{
            playersState[id] = { hand: tiles.splice(0,handSize) };
        });

        // Determine starter based on newly dealt hands
        let starter = getStartingPlayer(pIds, playersState);
        
        const updates={status:"playing",board:[],stock:tiles,playerOrder:pIds};
        pIds.forEach(id=>{
            updates[`players/${id}/hand`] = playersState[id].hand;
            updates[`players/${id}/count`] = handSize;
        });

        updates.turnIndex = starter ? pIds.indexOf(starter) : 0;
        updates.turnStartTime = firebase.database.ServerValue.TIMESTAMP;

        db.ref("games/"+currentgame).update(updates);
    }

    function renderGame(data) {
        const pIds = data.playerOrder;
        const myIdx = pIds.indexOf(myId);
        const oppDiv = document.getElementById('opponents'); oppDiv.innerHTML = "";
        
        for(let i=1; i<pIds.length; i++) {
            const tId = pIds[(myIdx + i) % pIds.length];
            const p = data.players[tId];
            const isTurn = (pIds[data.turnIndex] === tId);
            let cls = pIds.length === 2 ? 'pos-top' : (i===1 ? 'pos-right' : 'pos-left');
            oppDiv.innerHTML += `<div class="player-pos ${cls} ${isTurn?'active-turn':''}">
                ${p.name} <br> üÄÑ ${p.count}
            </div>`;
        }

        const myHand = data.players[myId].hand || [];
        document.getElementById('my-score').innerText = data.players[myId].score;
        const handDiv = document.getElementById('my-hand'); handDiv.innerHTML = "";
        
        myHand.forEach((t, i) => {
            const isSel = (i === selectedIdx) ? 'selected' : '';
            handDiv.innerHTML += `<div class="domino hand-tile ${isSel}" onclick="selectHand(${i})">
                <div class="pip-container">${getPips(t.a)}</div><div class="line"></div>
                <div class="pip-container">${getPips(t.b)}</div>
            </div>`;
        });

        const isMyTurn = pIds[data.turnIndex] === myId;
        const board = data.board || [];
        const btn = document.getElementById('draw-btn');
        
        if(isMyTurn && !hasMove(myHand, board) && data.stock && data.stock.length > 0) {
            btn.classList.remove('hidden');
        } else {
            btn.classList.add('hidden');
            if(isMyTurn && !hasMove(myHand, board) && (!data.stock || data.stock.length === 0)) {
                setTimeout(passTurn, 1500);
            }
        }

        // Render board first to define coords
        const pos = renderBoard(board);
        
        // Render Ghosts using the calculated positions
        if(selectedIdx !== -1 && isMyTurn) {
             renderGhosts(board, myHand[selectedIdx], pos);
        }
    }

    /* ============================
       REAL DOMINO SNAKE LAYOUT
    ============================ */
    function calculateSnakePositions(board){
        let pos=[];
        let x=0,y=0;
        let dir=1;
        let count=0;

        board.forEach((t,i)=>{
            let isDouble = t.a===t.b;
            let rot = isDouble ? 90 : (dir===1?0:0);

            pos.push({x,y,rot,dir});

            count++;
            if(count>=ROW_LIMIT){
                y += TILE_H + 20;
                dir *= -1;
                count=0;
            }else{
                x += (TILE_W+GAP)*dir;
            }
        });

        // Centering
        if(pos.length > 0) {
            let minX=Math.min(...pos.map(p=>p.x));
            let maxX=Math.max(...pos.map(p=>p.x));
            let minY=Math.min(...pos.map(p=>p.y));
            let maxY=Math.max(...pos.map(p=>p.y));
            let cx=(minX+maxX)/2;
            let cy=(minY+maxY)/2;
            pos.forEach(p=>{p.x-=cx;p.y-=cy});
        }
        return pos;
    }

    /* ============================
       RENDER BOARD ‚Äì FIX ROTATION
    ============================ */
    function renderBoard(board){
        const d=document.getElementById("game-board");
        d.innerHTML="";
        
        if(board.length === 0) {
             d.innerHTML = `<div class="drop-zone dz-v" onclick="playTile('first')">+</div>`;
             return [];
        }

        const pos=calculateSnakePositions(board);
        let connector=null;

        board.forEach((t,i)=>{
            let {x,y,rot,dir}=pos[i];
            let a=t.a,b=t.b;

            if(i===0){
                // For the first tile, we need to know the next connection to orient it
                if(board.length > 1) {
                    const t1 = board[1];
                    // If t1 connects to 'a', then 'a' is the connector side
                    if(t1.a === a || t1.b === a) connector = a;
                    else connector = b;
                    
                    // Logic to visually swap first tile so connector is towards next tile direction
                    // If moving right (dir=1), right side should be connector.
                    // But in HTML flow, right side is the second element (b).
                    if (dir === 1) {
                        if (a === connector) { /* b | a(conn) */ [a,b]=[b,a]; }
                    } else {
                        // Moving left? Rare for tile 0, but if so:
                        if (b === connector) { /* a(conn) | b */ [a,b]=[b,a]; }
                    }
                } else {
                    connector=b; // Default for single tile
                }
            }else{
                // Logic: One side must match previous connector
                if(a===connector){
                    connector=b; // New open end is b
                }else if(b===connector){
                    connector=a; // New open end is a
                    [a,b]=[b,a]; // Swap visual so 'b'(old conn) is on left?
                }
                
                // Visual Correction based on Direction
                // If moving Right: [Match | New]
                // If moving Left:  [New | Match]
                
                // Above logic [a,b]=[b,a] puts 'Match' in 'a' position.
                // Standard DOM: <div>a</div><div>b</div>
                
                if (dir === 1) {
                    // Right: We want Match on Left. a is Match. Correct.
                } else {
                    // Left: We want Match on Right. b should be Match.
                    // Currently a is Match. So Swap.
                    [a,b]=[b,a];
                }
            }

            d.innerHTML+=`
            <div class="domino board-tile ${a===b?'double':''}"
            style="left:${x}px;top:${y}px;
            transform:translate(-50%,-50%) rotate(${rot}deg)">
                <div class="pip-container">${getPips(a)}</div>
                <div class="line"></div>
                <div class="pip-container">${getPips(b)}</div>
            </div>`;
        });
        
        return pos;
    }

    function renderGhosts(board, tile, pos) {
        const div = document.getElementById('game-board');
        const head = board[0].a; // Logic needs verify: Is board[0].a always Head?
        // Actually, with unshift/push, board[0] is Head, board[len-1] is Tail.
        // But we need to check if tile matches board[0].a or board[0].b depending on orientation
        // Simplified: Check both ends of board against tile
        
        // Since we don't store oriented board, checking match is:
        const tFirst = board[0];
        const tLast = board[board.length-1];
        
        // Find open ends
        // We know logical connector flow, but simpler:
        // We can just try to put ghost at visual ends calculated in 'pos'
        
        // Calc Right Ghost (Tail)
        const lastPos = pos[pos.length-1];
        let lx = lastPos.x, ly = lastPos.y, lDir = lastPos.dir;
        // Calc next step
        let gx = lx, gy = ly;
        if( (board.length) % ROW_LIMIT === 0 ) {
             gy += TILE_H + 20; // Drop down
        } else {
             gx += (TILE_W+GAP)*lDir;
        }
        
        // Check if tile matches Tail
        // Since renderBoard orients visually, we rely on data
        // Logic: playTile('tail') pushes.
        // Does tile match tLast?
        if(tile.a === tLast.b || tile.b === tLast.b || tile.a === tLast.a || tile.b === tLast.a) {
             div.innerHTML += `<div class="drop-zone" style="left:${gx}px; top:${gy}px; transform:translate(-50%,-50%)" onclick="playTile('tail')">+</div>`;
        }
        
        // Calc Left Ghost (Head)
        const firstPos = pos[0];
        // Just put left of first
        let fx = firstPos.x - (TILE_W+GAP); // Assume start is always dir 1
        let fy = firstPos.y;
        
        if(tile.a === tFirst.a || tile.b === tFirst.a || tile.a === tFirst.b || tile.b === tFirst.b) {
             div.innerHTML += `<div class="drop-zone" style="left:${fx}px; top:${fy}px; transform:translate(-50%,-50%)" onclick="playTile('head')">+</div>`;
        }
    }

    function selectHand(i) {
        if(gameData.playerOrder[gameData.turnIndex] !== myId) return;
        selectedIdx = (selectedIdx === i) ? -1 : i;
        renderGame(gameData);
    }
    
    function cancelSelection(e) {
        if(!e.target.closest('.domino') && !e.target.closest('.drop-zone')) {
            selectedIdx = -1;
            renderGame(gameData);
        }
    }

    function playTile(side) {
        if(selectedIdx === -1) return;
        
        const hand = gameData.players[myId].hand;
        const tile = hand[selectedIdx];
        let board = [...gameData.board];
        let finalTile = {...tile};

        if(board.length === 0) {
            board.push(finalTile);
        } else if (side === 'head') {
            // Match board[0].a (assuming board[0] oriented [a|b] where a is open)
            // But strict logic: board[0] is [Open | Connected]
            // We need to verify what is Open.
            // Simplified: Try match a, if not match b.
            const target = board[0].a; // Usually unshifted side
            if(finalTile.a === target || finalTile.b === target) {
                 if(finalTile.a === target) finalTile = {a:tile.b, b:tile.a}; // Flip
                 board.unshift(finalTile);
            } else {
                 // Try matching board[0].b (if oriented differently)
                 // This part relies on consistent board state
                 if(finalTile.a === board[0].b) finalTile = {a:tile.b, b:tile.a};
                 board.unshift(finalTile);
            }
        } else {
            // Tail
            const target = board[board.length-1].b;
            if(finalTile.b === target) finalTile = {a:tile.b, b:tile.a};
            board.push(finalTile);
        }

        hand.splice(selectedIdx, 1);
        selectedIdx = -1;

        if(hand.length === 0) {
            db.ref('games/'+currentgame).update({
                status: 'finished',
                winnerName: myName,
                board: board,
                [`players/${myId}/hand`]: hand,
                [`players/${myId}/count`]: 0
            });
        } else {
            const nextIdx = (gameData.turnIndex + 1) % gameData.playerOrder.length;
            db.ref('games/'+currentgame).update({
                board: board,
                turnIndex: nextIdx,
                [`players/${myId}/hand`]: hand,
                [`players/${myId}/count`]: hand.length
            });
        }
    }

    function drawTile() {
        let stock = gameData.stock;
        let hand = gameData.players[myId].hand;
        hand.push(stock.pop());
        db.ref('games/'+currentgame).update({
            stock: stock,
            [`players/${myId}/hand`]: hand,
            [`players/${myId}/count`]: hand.length
        });
    }

    function passTurn() {
        const nextIdx = (gameData.turnIndex + 1) % gameData.playerOrder.length;
        db.ref('games/'+currentgame).update({ turnIndex: nextIdx });
        showToast("ŸÑÿß ŸäŸàÿ¨ÿØ ŸÑÿπÿ® - ÿ™ŸÖ ÿßŸÑÿ™ŸÖÿ±Ÿäÿ±");
    }

    function hasMove(hand, board) {
        if(board.length === 0) return true;
        const head = board[0].a; // Approx check
        const tail = board[board.length-1].b;
        return hand.some(t => t.a === head || t.b === head || t.a === tail || t.b === tail);
    }

    function getPips(n) {
        const m={0:[], 1:['p1'],2:['p2-1','p2-2'],3:['p3-1','p3-2','p3-3'],4:['p4-1','p4-2','p4-3','p4-4'],5:['p5-1','p5-2','p5-3','p5-4','p5-5'],6:['p6-1','p6-2','p6-3','p6-4','p6-5','p6-6']};
        return (m[n]||[]).map(c=>`<div class="pip ${c}"></div>`).join('');
    }
</script>
</body>
</html>
