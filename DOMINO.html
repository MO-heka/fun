<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>DOMINO HEKA ULTRA</title>
    <link href="https://fonts.googleapis.com/css2?family=Righteous&family=Cairo:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    
    <style>
        :root { 
            --bg-color: #0f172a; 
            --glass-bg: rgba(30, 41, 59, 0.9);
            --domino-white: #f1f2f6;
            --domino-black: #1e272e;
            --accent-color: #3b82f6; 
            --gold: #fbbf24;
            --danger: #ef4444;
            --drop-zone: rgba(251, 191, 36, 0.4);
        }

        body { 
            font-family: 'Cairo', sans-serif; 
            background-color: var(--bg-color);
            background-image: radial-gradient(#1e293b 15%, transparent 16%), radial-gradient(#1e293b 15%, transparent 16%);
            background-size: 60px 60px;
            color: #e2e8f0; margin: 0; overflow: hidden; height: 100vh;
            display: flex; flex-direction: column; user-select: none;
            touch-action: manipulation;
        }

        h1.game-title {
            font-family: 'Righteous', cursive; font-size: 1.5rem; color: var(--gold);
            text-shadow: 0 0 15px rgba(251, 191, 36, 0.4); margin: 5px 0; text-align: center; pointer-events: none;
            z-index: 10;
        }

        .container { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; position: relative; }
        .hidden { display: none !important; }

        /* Ø§Ù„Ø´Ø§Ø´Ø§Øª */
        .screen {
            background: var(--glass-bg); backdrop-filter: blur(12px); padding: 30px;
            border-radius: 20px; text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1); width: 90%; max-width: 400px; z-index: 100;
        }

        /* Ø¹Ù†Ø§ØµØ± Ø§Ù„ØªØ­ÙƒÙ… */
        input { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.2); padding: 10px; color: white; border-radius: 8px; text-align: center; outline: none; }
        button { background: var(--accent-color); color: white; padding: 10px 20px; border: none; border-radius: 8px; font-weight: bold; cursor: pointer; transition: 0.3s; margin: 5px; font-family: 'Cairo'; }
        button:active { transform: scale(0.95); }

        /* Ø§Ù„Ø¯ÙˆÙ…ÙŠÙ†Ùˆ */
        .domino { background-color: var(--domino-white); border-radius: 4px; box-shadow: 2px 2px 0px #555; display: flex; cursor: pointer; transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .pip-container { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); padding: 2px; width: 100%; height: 100%; box-sizing: border-box; }
        .pip { background-color: var(--domino-black); border-radius: 50%; width: 100%; height: 100%; box-shadow: inset 0 1px 1px rgba(0,0,0,0.5); }
        .line { background-color: #ccc; }

        .p1 { grid-area: 2 / 2; } .p2-1 { grid-area: 1 / 3; } .p2-2 { grid-area: 3 / 1; }
        .p3-1 { grid-area: 1 / 3; } .p3-2 { grid-area: 2 / 2; } .p3-3 { grid-area: 3 / 1; }
        .p4-1 { grid-area: 1 / 1; } .p4-2 { grid-area: 1 / 3; } .p4-3 { grid-area: 3 / 1; } .p4-4 { grid-area: 3 / 3; }
        .p5-1 { grid-area: 1 / 1; } .p5-2 { grid-area: 1 / 3; } .p5-3 { grid-area: 2 / 2; } .p5-4 { grid-area: 3 / 1; } .p5-5 { grid-area: 3 / 3; }
        .p6-1 { grid-area: 1 / 1; } .p6-2 { grid-area: 1 / 3; } .p6-3 { grid-area: 2 / 1; } .p6-4 { grid-area: 2 / 3; } .p6-5 { grid-area: 3 / 1; } .p6-6 { grid-area: 3 / 3; }

        /* ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„ÙŠØ¯ (ØªÙ… Ø§Ù„Ø¥ØµÙ„Ø§Ø­) */
        .hand-tile { width: 38px; height: 76px; flex-direction: column; margin: 0 5px; z-index: 10; flex-shrink: 0; }
        .hand-tile .line { height: 2px; width: 90%; margin: 2px auto; }
        .hand-tile .pip-container { width: 38px; height: 37px; } .hand-tile .pip { width: 7px; height: 7px; margin: auto; }
        
        .hand-tile.selected { transform: translateY(-30px) scale(1.1); box-shadow: 0 10px 20px rgba(0,0,0,0.5); border: 2px solid var(--gold); z-index: 50; }

        /* Ø§Ù„Ø·Ø§ÙˆÙ„Ø© - ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ù€ Absolute Positioning */
        .board-tile { 
            position: absolute; /* Ù„Ù„ØªÙ…Ø±ÙƒØ² Ø§Ù„Ø­Ø± */
            width: 64px; height: 32px; flex-direction: row; 
            transform-origin: center center;
            transition: all 0.5s ease;
        }
        .board-tile .line { width: 2px; height: 90%; margin: auto 2px; }
        .board-tile .pip-container { width: 31px; height: 32px; } .board-tile .pip { width: 6px; height: 6px; margin: auto; }
        
        /* Ø§Ù„Ø¯ÙˆÙŠØ´ (Double) */
        .board-tile.double { 
            /* Ø§Ù„Ø¯ÙˆÙŠØ´ ÙŠØ¨Ù‚Ù‰ Ø¨Ù†ÙØ³ Ø§Ù„Ø£Ø¨Ø¹Ø§Ø¯ Ù„ØªØ³Ù‡ÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨Ø§ØªØŒ Ù„ÙƒÙ† ÙŠØªÙ… ØªØ¯ÙˆÙŠØ±Ù‡ Ø¯Ø§Ø®Ù„ÙŠØ§Ù‹ Ø£Ùˆ ØªØºÙŠÙŠØ± Ø§ØªØ¬Ø§Ù‡Ù‡ */
            width: 32px; height: 64px; flex-direction: column; 
        }
        .board-tile.double .line { height: 2px; width: 90%; margin: 2px auto; }
        .board-tile.double .pip-container { width: 32px; height: 31px; }

        /* Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„Ø¥Ø³Ù‚Ø§Ø· (Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø§Ù„Ø£ØµÙØ±) */
        .drop-zone {
            position: absolute;
            border: 2px dashed var(--gold);
            background-color: var(--drop-zone);
            border-radius: 5px;
            animation: pulse 1s infinite;
            cursor: pointer;
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 20px; font-weight: bold;
            z-index: 5;
        }
        .drop-zone:hover { background-color: var(--gold); color: black; }
        .dz-h { width: 64px; height: 32px; } 
        .dz-v { width: 32px; height: 64px; }

        @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

        /* ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù„Ø¹Ø¨ */
        #game-interface { width: 100%; height: 100%; display: flex; flex-direction: column; }
        
        #table-surface {
            flex: 1; margin: 10px; border-radius: 20px; border: 4px solid #334155;
            background: rgba(15, 23, 42, 0.5); 
            position: relative; box-shadow: inset 0 0 50px black; overflow: auto; /* Scrollable */
            display: flex; justify-content: center; align-items: center;
        }
        
        /* Ø­Ø§ÙˆÙŠØ© Ø§Ù„Ù„Ø¹Ø¨ (ØªØªØ­Ø±Ùƒ Ø¨Ø§Ù„Ø¯Ø§Ø®Ù„) */
        #game-board-container {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.5s ease;
        }

        /* Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† */
        .player-pos {
            position: absolute; background: rgba(30, 41, 59, 0.95); padding: 5px 10px;
            border-radius: 10px; display: flex; flex-direction: column; align-items: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); min-width: 80px; z-index: 20;
        }
        .player-pos.active-turn { border: 2px solid var(--gold); box-shadow: 0 0 15px var(--gold); }
        .pos-top { top: 10px; left: 50%; transform: translateX(-50%); }
        .pos-left { top: 50%; left: 10px; transform: translateY(-50%); }
        .pos-right { top: 50%; right: 10px; transform: translateY(-50%); }
        .timer-bar { height: 3px; background: var(--danger); width: 100%; margin-top: 5px; transition: width 0.5s linear; }

        /* Ù…Ù†Ø·Ù‚ØªÙŠ (ØªÙ… Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ù„Ø¸Ù‡ÙˆØ± Ø§Ù„ÙŠØ¯ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„) */
        #my-area { 
            height: 180px; /* Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ */
            padding-bottom: env(safe-area-inset-bottom, 20px); /* Ø­Ù…Ø§ÙŠØ© Ù…Ù† Ø­ÙˆØ§Ù Ø§Ù„Ø¢ÙŠÙÙˆÙ† */
            background: rgba(0,0,0,0.8); display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; border-top: 1px solid #444; 
        }
        #my-hand { 
            display: flex; overflow-x: auto; 
            padding: 40px 20px 20px 20px; /* Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ù€ padding Ø§Ù„Ø¹Ù„ÙˆÙŠ Ù„Ø§Ø³ØªÙŠØ¹Ø§Ø¨ Ø­Ø±ÙƒØ© Ø§Ù„Ø§Ø±ØªÙØ§Ø¹ */
            width: 95%; align-items: center; 
            height: 100px;
            scrollbar-width: none; /* Ø¥Ø®ÙØ§Ø¡ Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ…Ø±ÙŠØ± */
        }
        #my-hand::-webkit-scrollbar { display: none; }
        
        #draw-btn { position: absolute; top: -50px; background: var(--gold); color: black; z-index: 50; box-shadow: 0 0 10px var(--gold); }

        /* Ø±Ø³Ø§Ù„Ø© Ù…Ù†Ø¨Ø«Ù‚Ø© */
        #toast {
            position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); color: white; padding: 10px 20px; border-radius: 20px;
            border: 1px solid var(--gold); z-index: 500; opacity: 0; transition: opacity 0.3s; pointer-events: none;
        }

        /* Ø§Ù„Ø´Ø§Øª */
        #chat-icon { position: fixed; bottom: 20px; left: 20px; width: 50px; height: 50px; background: var(--accent-color); border-radius: 50%; display: flex; justify-content: center; align-items: center; cursor: pointer; z-index: 200; }
        #chat-badge { position: absolute; top: -5px; right: -5px; background: red; color: white; width: 20px; height: 20px; border-radius: 50%; font-size: 12px; display: flex; justify-content: center; align-items: center; }
        #chat-box { position: fixed; bottom: 80px; left: 20px; width: 280px; height: 300px; background: var(--glass-bg); border-radius: 10px; display: flex; flex-direction: column; z-index: 200; }
        #chat-msgs { flex: 1; overflow-y: auto; padding: 10px; }
        .msg { background: rgba(255,255,255,0.1); padding: 5px; margin: 3px 0; border-radius: 5px; font-size: 13px; text-align: right; }
        .msg.mine { background: rgba(59, 130, 246, 0.4); align-self: flex-end; }
    </style>
</head>
<body>

    <h1 class="game-title">HEKA ULTRA</h1>

    <div id="toast"></div>

    <div class="container">
        <div id="screen-login" class="screen">
            <h2>ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„</h2>
            <input type="text" id="username" placeholder="Ø§Ø³Ù…Ùƒ">
            <button onclick="saveName()">Ø¯Ø®ÙˆÙ„</button>
        </div>

        <div id="screen-menu" class="screen hidden">
            <h3 id="welcome-msg"></h3>
            <button onclick="creategame()" style="background:#10b981; width:80%">Ø¥Ù†Ø´Ø§Ø¡ ØºØ±ÙØ©</button>
            <br>
            <input type="text" id="code-input" placeholder="ÙƒÙˆØ¯ Ø§Ù„ØºØ±ÙØ©" style="width:100px">
            <button onclick="joingame()">Ø¯Ø®ÙˆÙ„</button>
        </div>

        <div id="screen-lobby" class="screen hidden">
            <h2>ØºØ±ÙØ©: <span id="lobby-code" style="color:var(--gold)"></span></h2>
            <ul id="lobby-list" style="list-style:none; padding:0; text-align:right"></ul>
            <button id="start-btn" class="hidden" onclick="startGame()">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø¬ÙˆÙ„Ø©</button>
            <button onclick="leavegame()" style="background:var(--danger)">Ø®Ø±ÙˆØ¬</button>
        </div>

        <div id="screen-game" class="hidden" style="width:100%; height:100%">
            <div id="game-interface">
                <div style="padding:10px; display:flex; justify-content:space-between; align-items:center;">
                    <button onclick="leavegame()" style="background:var(--danger); font-size:12px; padding:5px 10px">Ø§Ù†Ø³Ø­Ø§Ø¨</button>
                    <span style="color:#aaa; font-size:12px">game: <span id="game-code"></span></span>
                </div>

                <div id="table-surface" onclick="cancelSelection(event)">
                    <div id="opponents"></div> 
                    <div id="game-board-container"></div> 
                </div>

                <div id="my-area">
                    <button id="draw-btn" class="hidden">Ø³Ø­Ø¨</button>
                    <div id="my-score-display" style="position:absolute; top:-25px; left:10px; color:var(--gold); font-weight:bold;">Ù†Ù‚Ø§ØªÙƒ: 0</div>
                    <div id="my-hand"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="screen-winner" class="screen hidden" style="position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); z-index:400; border:2px solid var(--gold);">
        <h1 style="color:var(--gold); font-size:3rem;">ğŸ† CHAMPION ğŸ†</h1>
        <h2 id="winner-name"></h2>
        <button onclick="leavegame()">Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</button>
    </div>

    <div id="chat-icon" class="hidden" onclick="toggleChat()">
        <div id="chat-badge" class="hidden">0</div>ğŸ’¬
    </div>
    <div id="chat-box" class="hidden">
        <div style="padding:5px; background:rgba(0,0,0,0.3); color:white; display:flex; justify-content:space-between;"><span>Chat</span><span onclick="toggleChat()" style="cursor:pointer">x</span></div>
        <div id="chat-msgs"></div>
        <div style="display:flex; padding:5px;"><input id="chat-in" style="flex:1; margin:0"><button onclick="sendMsg()" style="margin:0 5px">></button></div>
    </div>

<script>
    // --- Config ---
    const firebaseConfig = { apiKey: "AIzaSyCp9_P3K__Sr76iKgaVG1iD4NluUqPtni4", authDomain: "heka-codenames.firebaseapp.com", projectId: "heka-codenames", storageBucket: "heka-domino.firebasestorage.app", messagingSenderId: "901713932504", appId: "1:901713932504:web:b6710ddf537cd3c7c4e7ad" };
    if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // --- Variables ---
    let myName="", myId="", currentgame="", isHost=false;
    let gameData={}, chatOpen=false, timerInt=null;
    let selectedIdx = -1; 
    
    // Ø«ÙˆØ§Ø¨Øª Ø§Ù„Ø±Ø³Ù… Ù„Ù„Ø·Ø§ÙˆÙ„Ø© (Snake Layout)
    const TILE_W = 68; // Ø§Ù„Ø¹Ø±Ø¶ Ù…Ø¹ Ø§Ù„Ù‡Ø§Ù…Ø´
    const TILE_H = 34;
    const ROW_LIMIT = 6; // Ø£Ù‚ØµÙ‰ Ø¹Ø¯Ø¯ ÙƒØ±ÙˆØª ÙÙŠ Ø§Ù„ØµÙ Ø§Ù„ÙˆØ§Ø­Ø¯

    // --- Init ---
    window.onload = () => {
        if(localStorage.getItem('heka_ultra_name')) {
            document.getElementById('username').value = localStorage.getItem('heka_ultra_name');
            saveName();
        }
    };

    function show(id) {
        document.querySelectorAll('.screen, #screen-game').forEach(e => e.classList.add('hidden'));
        document.getElementById(id).classList.remove('hidden');
    }
    function saveName() {
        myName = document.getElementById('username').value.trim();
        if(!myName) return;
        localStorage.setItem('heka_ultra_name', myName);
        document.getElementById('welcome-msg').innerText = `ÙŠØ§ Ù‡Ù„Ø§ Ø¨Ù€ ${myName}`;
        show('screen-menu');
    }

    // --- Toast Msg ---
    function showToast(msg) {
        const t = document.getElementById('toast');
        t.innerText = msg; t.style.opacity=1;
        setTimeout(()=>t.style.opacity=0, 2000);
    }

    // --- game Logic ---
    function creategame() {
        const code = Math.floor(1000+Math.random()*9000).toString();
        myId = Date.now().toString();
        db.ref('games/'+code).set({
            status: 'waiting', host: myId, roundCount: 0,
            players: { [myId]: { name: myName, score: 0, hand:[], count:0, isBot:false } }
        }).then(()=>entergame(code, true));
    }
    function joingame() {
        const code = document.getElementById('code-input').value.trim();
        if(!code) return;
        myId = Date.now().toString();
        db.ref('games/'+code).once('value', s => {
            if(!s.exists()) return alert("ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©");
            if(s.val().status !== 'waiting') return alert("Ø¨Ø¯Ø£Øª Ø¨Ø§Ù„ÙØ¹Ù„");
            if(Object.keys(s.val().players||{}).length >=4) return alert("Ù…Ù…ØªÙ„Ø¦Ø©");
            db.ref(`games/${code}/players/${myId}`).set({ name: myName, score: 0, hand:[], count:0, isBot:false })
            .then(()=>entergame(code, false));
        });
    }
    function entergame(code, host) {
        currentgame = code; isHost = host;
        document.getElementById('lobby-code').innerText = code;
        document.getElementById('game-code').innerText = code;
        show('screen-lobby');
        if(isHost) document.getElementById('start-btn').classList.remove('hidden');
        document.getElementById('chat-icon').classList.remove('hidden');
        db.ref(`games/${code}/players/${myId}`).onDisconnect().update({ isBot: true });
        listen();
    }
    function leavegame() {
        if(currentgame && myId) db.ref(`games/${currentgame}/players/${myId}`).update({ isBot: true });
        location.reload();
    }

    // --- Listen ---
    function listen() {
        db.ref(`games/${currentgame}`).on('value', s => {
            const d = s.val();
            if(!d) return location.reload();
            gameData = d;
            if(d.status === 'waiting') updateLobby(d.players);
            else if(d.status === 'playing') {
                if(document.getElementById('screen-game').classList.contains('hidden')) show('screen-game');
                updateGame(d);
                checkTimer(d);
            } 
            else if (d.status === 'finished') {
                alert(`Ø§Ù„ÙØ§Ø¦Ø²: ${d.roundWinnerName}`);
                if(isHost) setTimeout(startGame, 3000);
            }
            else if (d.status === 'match_over') {
                document.getElementById('winner-name').innerText = d.matchWinnerName;
                document.getElementById('screen-winner').classList.remove('hidden');
            }
            updateChat(d.chat);
        });
    }
    function updateLobby(players) {
        const list = document.getElementById('lobby-list'); list.innerHTML = "";
        Object.values(players||{}).forEach(p => list.innerHTML += `<li>${p.name} ${p.isBot?'ğŸ¤–':''} - ğŸ†${p.score}</li>`);
    }

    // --- Game Logic ---
    function startGame() {
        const pIds = Object.keys(gameData.players);
        if(pIds.length < 2) return alert("2 Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø¹ Ø§Ù„Ø£Ù‚Ù„");
        pIds.sort();
        let tiles = [];
        for(let i=0; i<=6; i++) for(let j=i; j<=6; j++) tiles.push({a:i, b:j});
        let handSize = 7;
        if(pIds.length === 3) { tiles = tiles.filter(t => !(t.a===0 && t.b===0)); handSize = 9; }
        tiles.sort(()=>Math.random()-0.5);
        const updates = { status: 'playing', board: [], stock: tiles, playerOrder: pIds };
        let startTurnIndex = 0, hasSixSix = -1;
        pIds.forEach((id, idx) => {
            const hand = tiles.splice(0, handSize);
            updates[`players/${id}/hand`] = hand;
            updates[`players/${id}/count`] = handSize;
            if(gameData.roundCount === 0 && hand.some(t => t.a===6 && t.b===6)) hasSixSix = idx;
        });
        if(gameData.roundCount === 0) startTurnIndex = (hasSixSix !== -1) ? hasSixSix : 0;
        else if(gameData.lastWinnerId) { const idx = pIds.indexOf(gameData.lastWinnerId); startTurnIndex = (idx !== -1) ? idx : 0; }
        
        updates['turnIndex'] = startTurnIndex;
        updates['turnStartTime'] = firebase.database.ServerValue.TIMESTAMP;
        updates['roundCount'] = (gameData.roundCount || 0) + 1;
        db.ref('games/'+currentgame).update(updates);
    }

    function updateGame(data) {
        const pIds = data.playerOrder;
        const myIdx = pIds.indexOf(myId);
        const turnId = pIds[data.turnIndex];
        
        // Opponents
        const oppDiv = document.getElementById('opponents'); oppDiv.innerHTML = "";
        const count = pIds.length;
        for(let i=1; i<count; i++) {
            const tIdx = (myIdx + i) % count; const tId = pIds[tIdx]; const p = data.players[tId];
            let cls = "pos-top";
            if(count===3) cls = (i===1) ? "pos-right" : "pos-left";
            if(count===4) cls = (i===1) ? "pos-right" : (i===2 ? "pos-top" : "pos-left");
            const isTurn = (turnId === tId);
            oppDiv.innerHTML += `<div class="player-pos ${cls} ${isTurn?'active-turn':''}">
                <div style="font-size:20px">ğŸ‘¤</div><div>${p.name} ${p.isBot?'ğŸ¤–':''}</div>
                <div style="color:#aaa">${p.count} ğŸ€„</div><div class="p-score">${p.score} pts</div>
                ${isTurn ? '<div class="timer-bar" id="tbar-'+tId+'"></div>' : ''}</div>`;
        }

        // Me
        document.getElementById('my-score-display').innerText = `Ù†Ù‚Ø§Ø·Ùƒ: ${data.players[myId].score}`;
        const myArea = document.getElementById('my-area');
        if(turnId === myId) {
            myArea.style.borderTop = "3px solid var(--gold)";
            if(!document.getElementById('my-timer')) myArea.insertAdjacentHTML('afterbegin', `<div id="my-timer" class="timer-bar" style="position:absolute; top:0; width:100%"></div>`);
            checkAutoPass(data);
        } else {
            myArea.style.borderTop = "1px solid #444";
            if(document.getElementById('my-timer')) document.getElementById('my-timer').remove();
            selectedIdx = -1; 
        }

        // Render Board with Snake Logic
        renderBoard(data.board||[]);
        if(selectedIdx === -1) renderHand(data.players[myId].hand||[]); 
        
        // Draw Button
        const btn = document.getElementById('draw-btn'); btn.classList.add('hidden');
        if(turnId === myId && count === 2 && !hasMove(data.players[myId].hand, data.board)) {
            if(data.stock && data.stock.length > 0) { btn.classList.remove('hidden'); btn.onclick = drawTile; }
        }
    }

    // --- Play System ---
    function selectTile(idx) {
        const pIds = gameData.playerOrder;
        if(pIds[gameData.turnIndex] !== myId) return; 

        const hand = gameData.players[myId].hand;
        const board = gameData.board || [];
        const tile = hand[idx];

        if(selectedIdx === idx) { cancelSelection(); return; }

        if(board.length === 0) {
            if(gameData.roundCount === 1) {
                const has66 = hand.findIndex(t => t.a===6 && t.b===6);
                if(has66 !== -1 && (tile.a!==6 || tile.b!==6)) {
                    showToast("Ù„Ø§Ø²Ù… ØªÙ„Ø¹Ø¨ 6-6 Ø§Ù„Ø£ÙˆÙ„!"); return;
                }
            }
        }

        selectedIdx = idx;
        renderHand(hand);
        renderBoardWithGhosts(board, tile);
    }

    function cancelSelection(e) {
        if(e && e.target.closest('.domino')) return;
        selectedIdx = -1;
        renderHand(gameData.players[myId].hand);
        renderBoard(gameData.board || []);
    }

    function renderBoardWithGhosts(board, tile) {
        renderBoard(board); // Render base board first to get coordinates
        const container = document.getElementById('game-board-container');

        if(board.length === 0) {
            const ghost = document.createElement('div');
            ghost.className = "drop-zone dz-h";
            ghost.innerHTML = "+";
            ghost.onclick = () => commitMove('any');
            // Center ghost
            ghost.style.left = "0px"; ghost.style.top = "0px";
            container.appendChild(ghost);
            return;
        }

        const l = board[0].a;
        const r = board[board.length-1].b;
        const canLeft = (tile.a === l || tile.b === l);
        const canRight = (tile.a === r || tile.b === r);

        // Get coordinates from the render logic helpers
        const leftCoords = getSnakeCoords(-1); 
        const rightCoords = getSnakeCoords(board.length);

        if(canLeft) {
            const isDouble = (tile.a === tile.b);
            const ghost = document.createElement('div');
            ghost.className = `drop-zone ${isDouble?'dz-v':'dz-h'}`;
            ghost.innerHTML = "+";
            ghost.style.left = leftCoords.x + "px";
            ghost.style.top = leftCoords.y + (isDouble?-16:0) + "px"; // Adjust for double height
            ghost.onclick = () => commitMove('left');
            container.appendChild(ghost);
        }

        if(canRight) {
            const isDouble = (tile.a === tile.b);
            const ghost = document.createElement('div');
            ghost.className = `drop-zone ${isDouble?'dz-v':'dz-h'}`;
            ghost.innerHTML = "+";
            ghost.style.left = rightCoords.x + "px";
            ghost.style.top = rightCoords.y + (isDouble?-16:0) + "px";
            ghost.onclick = () => commitMove('right');
            container.appendChild(ghost);
        }
    }

    // --- Snake Logic Coordinates Helper ---
    function getSnakeCoords(index) {
        // Adjust index to start from 0 for the first tile placed
        // But logic is relative. Let's assume index 0 is at (0,0)
        // This function returns visual X,Y for any logical index in the snake
        // Index can be negative (prepending) or large (appending)
        
        // Normalize: We map the board array to 0..length-1. 
        // Index -1 means "Before 0", Index Length means "After last".
        
        // Simplified approach: Treat the board as a sequence starting from 0 visual index.
        // We need to shift everything visually based on where the "Start" of the array is relative to the visual grid.
        // Actually, easiest is: Board[0] is always Visual Index 0? No, that shifts the whole snake.
        // Let's stick to: The board is linear. We just map i => (x,y).
        
        // Logic:
        // Row = floor(i / 6)
        // If Row is Even: x = (i % 6) * W
        // If Row is Odd:  x = (5 - (i % 6)) * W (Reverse direction)
        // y = Row * H * 1.5
        
        // Wait, for negative index (Left side ghost)?
        // We can't handle negative index easily in this modulo logic.
        // Hack: We render Board[0] at a calculated offset so that negative indices don't happen, OR
        // simpler: The "Left" ghost is simply the visual coordinate of "Index -1" if we supported it.
        // But "Index -1" in snake logic is complex (it might be up, or left, or right depending on row).
        
        // Since we re-render fully on every move, let's treat the Current Board as indices 0 to N.
        // Left Ghost = Visual position of a theoretical tile inserted at start -> effectively shifts everyone?
        // No, in "renderBoardWithGhosts", we just want to know where to put the clicker.
        // If we insert Left, the whole snake shifts. That's fine for the game logic.
        // VISUALLY: The Left Ghost should appear at the logical position of index "-1".
        // But since we can't do index -1, let's say:
        // Left Ghost is at (Relative to Tile 0). 
        // Tile 0 is at Row 0, Col 0.
        // Tile -1 would be at Row 0, Col -1? -> Invalid.
        
        // Better Solution for UI:
        // Always render board starting from index X.
        // Actually, since the user wants "Snake", and the array grows at both ends, 
        // it's best to assume the board starts at visual index 0 for Board[0].
        // The Left Ghost is handled by shifting the whole container or just placing it "Before" 0.
        // "Before 0" is ( -TILE_W, 0 ).
        
        const row = Math.floor(index / ROW_LIMIT);
        const col = index % ROW_LIMIT;
        
        let x = 0;
        let y = row * 50; // Vertical spacing

        if (row % 2 === 0) { // Even row: Left to Right
            x = col * TILE_W;
            // Transition to next row check
            if (col < 0) { // Handle the "Left Ghost" case for row 0
                 x = col * TILE_W; 
            }
        } else { // Odd row: Right to Left
            x = (ROW_LIMIT - 1 - col) * TILE_W;
        }

        // Adjust for index being negative (Left Ghost specific case simplified)
        if (index === -1) return { x: -TILE_W, y: 0 }; 

        return { x, y };
    }

    function renderBoard(board) {
        const container = document.getElementById('game-board-container');
        container.innerHTML = "";
        
        // Calculate center to pan the view
        let maxX = 0, maxY = 0;
        
        board.forEach((t, i) => {
            const coords = getSnakeCoords(i);
            const isDouble = (t.a === t.b);
            
            // Adjust double position to center it in the slot
            let finalX = coords.x + (isDouble ? 16 : 0);
            let finalY = coords.y - (isDouble ? 16 : 0);
            
            // Generate HTML
            const el = document.createElement('div');
            el.className = `domino board-tile ${isDouble ? 'double' : ''}`;
            el.style.left = `${finalX}px`;
            el.style.top = `${finalY}px`;
            
            // Rotation based on connection? 
            // For snake view, we just lay them out flat in slots usually.
            // But to look good, we can rotate doubles. CSS .double handles the vertical look.
            // Horizontal tiles are default.
            
            el.innerHTML = `<div class="pip-container">${getPips(t.a)}</div><div class="line"></div><div class="pip-container">${getPips(t.b)}</div>`;
            container.appendChild(el);
            
            if(coords.x > maxX) maxX = coords.x;
            if(coords.y > maxY) maxY = coords.y;
        });
        
        // Auto-center logic?
        // Since absolute positions start at 0,0 and go positive X/Y.
        // We can just rely on the container centering.
        // But if we have negative ghost (Left), it might clip.
        // We will just let the user scroll #table-surface which has overflow:auto.
        // To ensure scrollability, set container width/height
        container.style.width = (Math.min(board.length, ROW_LIMIT) * TILE_W) + "px";
        container.style.height = (maxY + 60) + "px";
    }

    function commitMove(side) {
        if(selectedIdx === -1) return;
        const hand = gameData.players[myId].hand;
        const tile = hand[selectedIdx];
        let board = [...(gameData.board || [])];
        let newTile = {...tile};

        if(side === 'any' || board.length === 0) {
            board.push(newTile);
        } else if (side === 'left') {
            if(newTile.a === board[0].a) newTile = {a:tile.b, b:tile.a};
            board.unshift(newTile);
        } else { // right
            if(newTile.b === board[board.length-1].b) newTile = {a:tile.b, b:tile.a};
            board.push(newTile);
        }

        hand.splice(selectedIdx, 1);
        selectedIdx = -1;

        if(hand.length === 0) handleRoundWin(myId, board);
        else nextTurn(board, hand);
    }

    // --- Helpers & Logic ---
    function checkAutoPass(data) {
        const hand = data.players[myId].hand || [];
        const board = data.board || [];
        const stock = data.stock || [];
        const canDraw = (Object.keys(data.players).length === 2 && stock.length > 0);
        
        if(!hasMove(hand, board) && !canDraw) {
            showToast("ğŸš« Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù„Ø¹Ø¨ - Pass");
            setTimeout(() => {
                const pIds = data.playerOrder;
                const next = (data.turnIndex + 1) % pIds.length;
                db.ref('games/'+currentgame).update({
                    turnIndex: next, turnStartTime: firebase.database.ServerValue.TIMESTAMP
                });
            }, 1500);
        }
    }
    
    function checkTimer(data) {
        if(timerInt) clearInterval(timerInt);
        const startTime = data.turnStartTime || Date.now();
        const turnId = data.playerOrder[data.turnIndex];
        const playerObj = data.players[turnId];

        if(playerObj.isBot) {
            if(isHost) setTimeout(() => autoBot(turnId), 1000);
            return; 
        }
        
        timerInt = setInterval(() => {
            const elapsed = (Date.now() - startTime) / 1000;
            const remaining = 40 - elapsed;
            const bar = document.getElementById(turnId===myId ? 'my-timer' : 'tbar-'+turnId);
            if(bar) bar.style.width = Math.max(0, (remaining/40)*100) + "%";

            if(remaining <= 0) {
                clearInterval(timerInt);
                if(turnId === myId) autoBot(myId);
                else if(isHost && playerObj.isBot) autoBot(turnId);
            }
        }, 1000);
    }

    function nextTurn(board, hand) {
        const pIds = gameData.playerOrder;
        const next = (gameData.turnIndex + 1) % pIds.length;
        db.ref('games/'+currentgame).update({
            board: board, turnIndex: next, turnStartTime: firebase.database.ServerValue.TIMESTAMP,
            [`players/${myId}/hand`]: hand, [`players/${myId}/count`]: hand.length
        });
    }
    function handleRoundWin(winnerId, board) {
        let total = 0;
        Object.keys(gameData.players).forEach(id => {
            if(id !== winnerId) (gameData.players[id].hand||[]).forEach(t => total += (t.a + t.b));
        });
        const newScore = (gameData.players[winnerId].score || 0) + total;
        const up = {
            [`players/${winnerId}/score`]: newScore, status: 'finished', lastWinnerId: winnerId,
            roundWinnerName: gameData.players[winnerId].name, board: board, [`players/${winnerId}/hand`]: []
        };
        if(newScore >= 101) { up.status = 'match_over'; up.matchWinnerName = gameData.players[winnerId].name; }
        db.ref('games/'+currentgame).update(up);
    }
    function drawTile() {
        let stock = gameData.stock || [];
        if(stock.length === 0) return;
        const t = stock.pop();
        const hand = gameData.players[myId].hand; hand.push(t);
        db.ref('games/'+currentgame).update({ stock: stock, [`players/${myId}/hand`]: hand, [`players/${myId}/count`]: hand.length });
    }
    function hasMove(hand, board) {
        if(!board || board.length===0) return true;
        const l = board[0].a, r = board[board.length-1].b;
        return hand.some(t => t.a===l || t.b===l || t.a===r || t.b===r);
    }

    function renderHand(hand) {
        const d = document.getElementById('my-hand'); d.innerHTML = "";
        hand.forEach((t, i) => {
            const isSel = (i === selectedIdx) ? 'selected' : '';
            // add onclick attribute back
            d.innerHTML += createDomino(t, `hand-tile ${isSel}`, `onclick="selectTile(${i})"`);
        });
    }
    
    function createDomino(t, cls, attr) {
        return `<div class="domino ${cls}" ${attr}><div class="pip-container">${getPips(t.a)}</div><div class="line"></div><div class="pip-container">${getPips(t.b)}</div></div>`;
    }
    function getPips(n) {
        const m={1:['p1'],2:['p2-1','p2-2'],3:['p3-1','p3-2','p3-3'],4:['p4-1','p4-2','p4-3','p4-4'],5:['p5-1','p5-2','p5-3','p5-4','p5-5'],6:['p6-1','p6-2','p6-3','p6-4','p6-5','p6-6']};
        return (m[n]||[]).map(c=>`<div class="pip ${c}"></div>`).join('');
    }

    // --- Bot ---
    function autoBot(pId) {
        const p = gameData.players[pId];
        const hand = p.hand || [];
        const board = gameData.board || [];
        let played=false, playIdx=-1, side='right';

        if(board.length===0) { playIdx=0; side='any'; }
        else {
            const l=board[0].a, r=board[board.length-1].b;
            for(let i=0; i<hand.length; i++) {
                if(hand[i].a===r || hand[i].b===r) { playIdx=i; side='right'; break; }
                if(hand[i].a===l || hand[i].b===l) { playIdx=i; side='left'; break; }
            }
        }

        if(playIdx !== -1) {
            const tile = hand[playIdx]; let newTile = {...tile}; let newBoard = [...board];
            if(side === 'left') { if(newTile.a===board[0].a) newTile={a:tile.b,b:tile.a}; newBoard.unshift(newTile); }
            else { const end=board.length?board[board.length-1].b:-1; if(board.length && newTile.b===end) newTile={a:tile.b,b:tile.a}; newBoard.push(newTile); }
            hand.splice(playIdx, 1);
            
            const next = (gameData.turnIndex + 1) % gameData.playerOrder.length;
            const up = { board: newBoard, turnIndex: next, turnStartTime: firebase.database.ServerValue.TIMESTAMP, [`players/${pId}/hand`]: hand, [`players/${pId}/count`]: hand.length };
            if(hand.length===0) {
                 up.status='finished'; up.roundWinnerName=p.name; up.lastWinnerId=pId;
                 let total=0; Object.keys(gameData.players).forEach(oid=>{ if(oid!==pId) (gameData.players[oid].hand||[]).forEach(t=>total+=t.a+t.b) });
                 up[`players/${pId}/score`] = (p.score||0)+total;
            }
            db.ref('games/'+currentgame).update(up);
        } else {
            if(Object.keys(gameData.players).length===2 && (gameData.stock||[]).length>0) {
                const stock = gameData.stock; const t = stock.pop(); hand.push(t);
                db.ref('games/'+currentgame).update({ stock:stock, [`players/${pId}/hand`]:hand, [`players/${pId}/count`]:hand.length });
            } else {
                const next = (gameData.turnIndex + 1) % gameData.playerOrder.length;
                db.ref('games/'+currentgame).update({ turnIndex: next, turnStartTime: firebase.database.ServerValue.TIMESTAMP });
            }
        }
    }

    // Chat
    function toggleChat(){ chatOpen=!chatOpen; document.getElementById('chat-box').classList.toggle('hidden'); document.getElementById('chat-badge').classList.add('hidden'); }
    function sendMsg(){ const i=document.getElementById('chat-in'); if(i.value) db.ref(`games/${currentgame}/chat`).push({n:myName, t:i.value}); i.value=""; }
    function updateChat(c){ const b=document.getElementById('chat-msgs'); b.innerHTML=Object.values(c||{}).map(m=>`<div class="msg ${m.n===myName?'mine':''}"><b>${m.n}:</b> ${m.t}</div>`).join(''); if(!chatOpen && c) document.getElementById('chat-badge').classList.remove('hidden'); }
</script>
</body>
</html>
