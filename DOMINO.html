<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ŸÑÿπÿ®ÿ© ÿßŸÑÿØŸàŸÖŸäŸÜŸà ÿßŸàŸÜŸÑÿßŸäŸÜ</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@500;700;900&display=swap" rel="stylesheet">

    <style>
        /* =========================================
           ‚ú® Premium Design System (2026 Edition)
        ========================================= */
        :root {
            --bg-dark: #0f172a;
            --bg-light: #1e293b;
            --primary: #6366f1;
            /* Indigo */
            --primary-glow: rgba(99, 102, 241, 0.4);
            --accent: #f43f5e;
            /* Rose */
            --highlight: #fbbf24;
            /* Amber */

            --glass-bg: rgba(30, 41, 59, 0.7);
            --glass-border: 1px solid rgba(255, 255, 255, 0.1);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);

            --tile-face: #f8fafc;
            --tile-back: #cbd5e1;
            --tile-ink: #1e293b;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Tajawal', sans-serif;
            background: radial-gradient(circle at 50% 120%, #1e1b4b, #0f172a);
            color: #fff;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* --- Layout --- */
        #game-layout {
            display: grid;
            grid-template-rows: auto auto 1fr auto !important;
            height: 100%;
            width: 100%;
            overflow: hidden;
            position: relative;
        }

        /* --- Views & Cards --- */
        .view {
            display: none;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 1;
        }

        .view.active {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .card {
            background: rgba(15, 23, 42, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: var(--glass-border);
            border-radius: 24px;
            padding: 2rem;
            width: 90%;
            max-width: 450px;
            text-align: center;
            box-shadow: var(--glass-shadow);
            animation: floatIn 0.5s ease-out;
        }

        @keyframes floatIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            font-size: 3rem;
            margin: 0;
            background: linear-gradient(135deg, #fff 0%, #94a3b8 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        }

        /* --- Inputs & Buttons --- */
        input[type="text"] {
            width: 100%;
            padding: 16px;
            margin: 15px 0;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #334155;
            border-radius: 16px;
            color: #fff;
            font-size: 1.1rem;
            text-align: center;
            font-family: inherit;
            transition: 0.3s;
        }

        input:focus {
            border-color: var(--primary);
            outline: none;
            box-shadow: 0 0 15px var(--primary-glow);
        }

        .btn {
            width: 100%;
            padding: 16px;
            border: none;
            border-radius: 16px;
            font-size: 1.1rem;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
            font-family: inherit;
            margin: 10px 0;
        }

        .btn:active {
            transform: scale(0.97);
        }

        .btn-create {
            background: linear-gradient(135deg, var(--primary), #4f46e5);
            color: white;
            box-shadow: 0 4px 15px var(--primary-glow);
        }

        .btn-blue {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            backdrop-filter: blur(5px);
        }

        .btn-danger {
            background: var(--accent);
            color: white;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(1);
            box-shadow: none;
        }

        /* --- Top Bar --- */
        #top-bar {
            padding: 10px 20px;
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 50;
        }

        .room-info {
            font-weight: 700;
            color: var(--highlight);
            letter-spacing: 1px;
        }

        /* --- Opponents --- */
        #opponents-area {
            display: flex;
            justify-content: center;
            gap: 15px;
            padding: 10px;
            background: transparent;
            min-height: 80px;
            align-items: flex-start;
        }

        .opponent {
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: 0.3s;
        }

        .opponent.active {
            border-color: var(--highlight);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.3);
            transform: translateY(5px);
        }

        .opponent-tiles {
            display: flex;
            gap: 2px;
            margin-top: 5px;
        }

        .mini-tile {
            width: 8px;
            height: 14px;
            background: #cbd5e1;
            border-radius: 2px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        /* --- Board --- */
        #board-area {
            position: relative;
            flex: 1;
            overflow: auto;
            /* Modern Grid Pattern */
            background-color: transparent;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.5);
        }

        #board-content {
            padding: 100px;
            display: flex;
            align-items: center;
            gap: 0;
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        /* --- Hand & Controls --- */
        #bottom-area {
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px 20px 30px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 100;
            box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.5);
        }

        #status-msg {
            margin-bottom: 10px;
            font-weight: bold;
            color: var(--highlight);
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        #my-hand {
            display: flex;
            gap: 12px;
            padding: 10px 5px;
            overflow-x: auto;
            width: 100%;
            min-height: 100px;
            justify-content: center;
            scroll-behavior: smooth;
        }

        #my-hand::-webkit-scrollbar {
            display: none;
        }

        /* --- 3D Tiles --- */
        .tile {
            width: 44px;
            height: 88px;
            background: linear-gradient(135deg, #fff 0%, #e2e8f0 100%);
            border-radius: 6px;
            position: relative;
            display: flex;
            flex-direction: column;
            box-shadow:
                1px 1px 0 #94a3b8,
                2px 2px 0 #94a3b8,
                3px 3px 0 #94a3b8,
                4px 4px 5px rgba(0, 0, 0, 0.4);
            transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            cursor: pointer;
            flex-shrink: 0;
            z-index: 1;
        }

        /* Inner detail line */
        .tile::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 10%;
            right: 10%;
            height: 2px;
            background: rgba(0, 0, 0, 0.1);
            box-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
        }

        .tile:hover {
            transform: translateY(-10px) rotate(-2deg);
            z-index: 10;
        }

        .tile:active {
            transform: translateY(2px);
            box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4);
        }

        .tile.disabled {
            filter: brightness(0.7) grayscale(0.2);
            cursor: default;
            transform: none !important;
            opacity: 0.6;
        }

        /* Horizontal play on board */
        .tile.horizontal {
            width: 88px;
            height: 44px;
            flex-direction: row;
            box-shadow:
                1px 1px 0 #94a3b8,
                2px 2px 0 #94a3b8,
                3px 3px 5px rgba(0, 0, 0, 0.4);
        }

        .tile.horizontal::after {
            top: 10%;
            bottom: 10%;
            left: 50%;
            right: auto;
            width: 2px;
            height: auto;
        }

        .tile.double-bone {
            transform: scale(1.05);
            z-index: 2;
        }

        /* Dots */
        .half {
            flex: 1;
            position: relative;
        }

        .dot {
            width: 8px;
            height: 8px;
            background: linear-gradient(135deg, #334155 0%, #0f172a 100%);
            border-radius: 50%;
            position: absolute;
            box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.8), 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        /* Dot Positions */
        .p1 {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .p2-tl {
            top: 20%;
            left: 20%;
        }

        .p2-tr {
            top: 20%;
            right: 20%;
        }

        .p2-bl {
            bottom: 20%;
            left: 20%;
        }

        .p2-br {
            bottom: 20%;
            right: 20%;
        }

        .p-mid-l {
            top: 50%;
            left: 20%;
            transform: translateY(-50%);
        }

        .p-mid-r {
            top: 50%;
            right: 20%;
            transform: translateY(-50%);
        }

        /* --- Controls --- */
        #controls {
            display: flex;
            gap: 15px;
            width: 100%;
            max-width: 400px;
            margin-top: 10px;
        }

        #btn-draw,
        #btn-pass {
            margin: 0;
            flex: 1;
            border-radius: 12px;
            font-size: 1rem;
        }

        /* --- Chat --- */
        #chat-container {
            position: absolute;
            bottom: 180px;
            right: 20px;
            width: 300px;
            height: 400px;
            background: rgba(30, 41, 59, 0.95);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 200;
        }

        #chat-container.minimized {
            height: 50px;
            width: 180px;
            bottom: 190px;
            border-radius: 25px;
        }

        #chat-header {
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 700;
            color: #fff;
            cursor: pointer;
        }

        #chat-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .msg {
            padding: 8px 12px;
            border-radius: 12px;
            font-size: 0.9rem;
            max-width: 80%;
            line-height: 1.4;
            color: #e2e8f0;
            background: rgba(255, 255, 255, 0.05);
        }

        .msg.me {
            align-self: flex-end;
            background: var(--primary);
            color: #fff;
            box-shadow: 0 4px 10px rgba(99, 102, 241, 0.3);
        }

        #chat-input-area {
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            display: flex;
            gap: 8px;
        }

        #chat-input {
            margin: 0;
            padding: 10px;
            border-radius: 10px;
            text-align: right;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #chat-send-btn {
            width: 40px;
            margin: 0;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            background: var(--primary);
        }

        /* --- Mobile Overrides --- */
        @media (max-width: 768px) {
            h1 {
                font-size: 2.2rem;
            }

            .card {
                padding: 1.5rem;
                width: 92%;
            }

            #opponents-area {
                padding: 5px;
                gap: 8px;
                overflow-x: auto;
                justify-content: flex-start;
            }

            .opponent {
                min-width: 70px;
                padding: 5px 8px;
            }

            .opponent div {
                font-size: 0.8rem;
            }

            #board-content {
                padding: 60px;
            }

            /* Responsive 3D Tiles Mobile */
            .tile {
                width: 38px;
                height: 76px;
                border-radius: 4px;
                box-shadow: 1px 1px 0 #94a3b8, 2px 2px 0 #94a3b8, 2px 2px 4px rgba(0, 0, 0, 0.3);
            }

            .tile.horizontal {
                width: 76px;
                height: 38px;
            }

            #bottom-area {
                padding: 10px 10px 20px 10px;
            }

            #my-hand {
                gap: 8px;
                justify-content: flex-start;
                padding-left: 10px;
            }

            #chat-container {
                width: 90%;
                right: 5%;
                bottom: 180px;
                max-width: none;
            }

            #chat-container.minimized {
                width: auto;
                right: 20px;
                left: auto;
                bottom: 200px;
            }
        }
    </style>
</head>

<body>

    <!-- SCREEN 1: LOGIN -->
    <div id="screen-login" class="view active">
        <div class="card">
            <div style="font-size: 60px;">üé≤</div>
            <h1>ÿßŸÑÿØŸàŸÖŸäŸÜŸà</h1>
            <p>ÿ≥ÿ¨ŸÑ ÿßÿ≥ŸÖŸÉ ŸÑŸÑÿ®ÿØÿ°</p>
            <input type="text" id="username-input" placeholder="ÿßŸÉÿ™ÿ® ÿßÿ≥ŸÖŸÉ ŸáŸÜÿß" maxlength="12">
            <button class="btn btn-create" onclick="saveName()">ÿØÿÆŸàŸÑ</button>
        </div>
    </div>

    <!-- SCREEN 2: LOBBY -->
    <div id="screen-lobby" class="view">
        <div class="card">
            <h2 id="welcome-msg">ÿ£ŸáŸÑÿßŸã</h2>

            <div style="margin: 20px 0;">
                <button onclick="createRoom()" class="btn btn-create">‚ú® ÿ•ŸÜÿ¥ÿßÿ° ÿ∫ÿ±ŸÅÿ© ÿ¨ÿØŸäÿØÿ©</button>
            </div>

            <div style="margin: 20px 0; border-top: 1px solid #334155; padding-top: 20px;">
                <p>ÿ£Ÿà ÿßŸÜÿ∂ŸÖ ŸÑÿ∫ÿ±ŸÅÿ© ŸÖŸàÿ¨ŸàÿØÿ©</p>
                <input type="text" id="room-code-input" placeholder="ŸÉŸàÿØ ÿßŸÑÿ∫ÿ±ŸÅÿ© (4 ÿ£ÿ±ŸÇÿßŸÖ)">
                <button onclick="joinRoom()" class="btn btn-blue">ÿßŸÜÿ∂ŸÖÿßŸÖ</button>
            </div>

            <div style="margin-top: 30px;">
                <input type="text" id="display-name" style="padding: 10px; font-size: 0.9rem; width: 60%;">
                <button onclick="updateName()" class="btn btn-secondary"
                    style="width: auto; padding: 10px 20px; display: inline-block;">ÿ≠ŸÅÿ∏ ÿßŸÑÿßÿ≥ŸÖ</button>
            </div>
        </div>
    </div>

    <!-- SCREEN 3: GAME -->
    <div id="screen-game" class="view" style="padding: 0;">
        <div id="game-layout">
            <!-- Top Bar -->
            <div id="top-bar">
                <div class="room-info" id="room-display">ÿ∫ÿ±ŸÅÿ©: ----</div>
                <button id="btn-start" class="btn btn-create"
                    style="display:none; width: auto; padding: 8px 20px; font-size: 16px; margin: 0;"
                    onclick="startGame()">ÿ®ÿØÿ° ÿßŸÑŸÑÿπÿ®</button>
            </div>

            <!-- Opponents -->
            <div id="opponents-area"></div>

            <!-- Board -->
            <div id="board-area">
                <div id="board-content"></div>
            </div>

            <!-- My Hand -->
            <div id="bottom-area">
                <div id="status-msg"
                    style="color: var(--highlight); margin-bottom: 5px; font-weight: bold; font-size: 1.1rem;">ÿßŸÜÿ™ÿ∏ÿßÿ±...
                </div>

                <div id="my-hand" class="my-hand"></div>

                <div id="controls" style="display: flex; gap: 10px; margin-top: 10px; width: 100%; max-width: 400px;">
                    <button id="btn-draw" class="btn btn-blue" onclick="drawTile()" disabled>ÿ≥ÿ≠ÿ® (<span
                            id="market-cnt">0</span>)</button>
                    <button id="btn-pass" class="btn btn-danger" onclick="passTurn()" disabled>ÿ™ÿÆÿ∑Ÿä</button>
                </div>
            </div>
        </div>

        <!-- Chat -->
        <div id="chat-container">
            <div id="chat-header" onclick="toggleChat()">
                <span>üí¨ ÿßŸÑŸÖÿ≠ÿßÿØÿ´ÿ©</span>
                <span>‚ñº</span>
            </div>
            <div id="chat-messages"></div>
            <div id="chat-input-area">
                <input type="text" id="chat-input" placeholder="ÿßŸÉÿ™ÿ® ÿ±ÿ≥ÿßŸÑÿ©...">
                <button id="chat-send-btn" onclick="sendMsg()">‚û§</button>
            </div>
        </div>
    </div>

    <!-- Script -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
        import { getDatabase, ref, set, get, onValue, update, push, child, remove, onDisconnect } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

        // --- Firebase Config ---
        const firebaseConfig = {
            apiKey: "AIzaSyCp9_P3K__Sr76iKgaVG1iD4NluUqPtni4",
            authDomain: "heka-codenames.firebaseapp.com",
            projectId: "heka-codenames",
            storageBucket: "heka-codenames.firebasestorage.app",
            messagingSenderId: "901713932504",
            appId: "1:901713932504:web:b6710ddf537cd3c7c4e7ad"
        };

        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // --- Global State ---
        let myName = localStorage.getItem('domino_username') || "";
        let myId = localStorage.getItem('domino_userid');
        if (!myId) {
            myId = 'user_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('domino_userid', myId);
        }
        let currentRoom = null;
        let playerList = []; // Array of {id, name, handCount, isMe}
        let myHand = [];
        let gameData = null;

        // --- DOM Elements ---
        const screens = {
            login: document.getElementById('screen-login'),
            lobby: document.getElementById('screen-lobby'),
            game: document.getElementById('screen-game')
        };

        // --- Initialization ---
        window.onload = () => {
            if (myName) {
                document.getElementById('display-name').value = myName;
                showScreen('lobby');
                document.getElementById('welcome-msg').innerText = `ÿ£ŸáŸÑÿßŸã ${myName}`;
            } else {
                showScreen('login');
            }
        };

        window.saveName = () => {
            const nameInput = document.getElementById('username-input').value.trim();
            if (nameInput) {
                myName = nameInput;
                localStorage.setItem('domino_username', myName);
                document.getElementById('welcome-msg').innerText = `ÿ£ŸáŸÑÿßŸã ${myName}`;
                document.getElementById('display-name').value = myName;
                showScreen('lobby');
            } else {
                alert("ÿßŸÑÿ±ÿ¨ÿßÿ° ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿßÿ≥ŸÖ");
            }
        };

        window.updateName = () => {
            const nameInput = document.getElementById('display-name').value.trim();
            if (nameInput) {
                myName = nameInput;
                localStorage.setItem('domino_username', myName);
                alert("ÿ™ŸÖ ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿßÿ≥ŸÖ");
                // If in room, could update there too ideally
            }
        }

        function showScreen(name) {
            Object.values(screens).forEach(s => s.classList.remove('active'));
            screens[name].classList.add('active');
        }

        // --- Lobby Logic ---

        window.createRoom = async () => {
            const roomCode = Math.floor(1000 + Math.random() * 9000).toString(); // 4 digit
            const roomRef = ref(db, `rooms/${roomCode}`);

            // Check if exists (unlikely but good practice)
            const snapshot = await get(roomRef);
            if (snapshot.exists()) return createRoom(); // retry

            const initialData = {
                status: 'waiting',
                host: myId,
                players: {
                    [myId]: { name: myName, score: 0, hand: false }
                },
                createdAt: Date.now()
            };

            await set(roomRef, initialData);
            enterRoom(roomCode);
        };

        window.joinRoom = async () => {
            const code = document.getElementById('room-code-input').value.trim();
            if (!code) return alert("ÿ£ÿØÿÆŸÑ ŸÉŸàÿØ ÿßŸÑÿ∫ÿ±ŸÅÿ©");

            const roomRef = ref(db, `rooms/${code}`);
            const snapshot = await get(roomRef);

            if (!snapshot.exists()) return alert("ÿßŸÑÿ∫ÿ±ŸÅÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©");
            const data = snapshot.val();

            if (data.status !== 'waiting') return alert("ÿßŸÑŸÑÿπÿ®ÿ© ÿ®ÿØÿ£ÿ™ ÿ®ÿßŸÑŸÅÿπŸÑ");
            if (Object.keys(data.players || {}).length >= 4) return alert("ÿßŸÑÿ∫ÿ±ŸÅÿ© ŸÖŸÖÿ™ŸÑÿ¶ÿ©");

            // Add self
            await update(child(roomRef, `players/${myId}`), {
                name: myName,
                score: 0,
                hand: false
            });

            enterRoom(code);
        };

        function enterRoom(code) {
            currentRoom = code;
            showScreen('game');
            document.getElementById('room-display').innerText = `ÿ∫ÿ±ŸÅÿ©: ${code}`;

            // Listen to Room Updates
            const roomRef = ref(db, `rooms/${code}`);

            // Remove old listeners if any by returning callback? (Simplification: reload page resets)
            onValue(roomRef, (snapshot) => {
                const data = snapshot.val();
                if (!data) {
                    alert("ÿ™ŸÖ ÿ•ÿ∫ŸÑÿßŸÇ ÿßŸÑÿ∫ÿ±ŸÅÿ©");
                    location.reload();
                    return;
                }
                gameData = data;
                syncGame(data);
            });

            // Handle Disconnect
            onDisconnect(child(roomRef, `players/${myId}`)).remove();
        }

        // --- Game Logic ---

        function syncGame(data) {
            // 1. Update Player List
            const pIds = Object.keys(data.players);
            playerList = pIds.map(id => ({
                id,
                name: data.players[id].name,
                handCount: data.players[id].hand ? data.players[id].hand.length : 0,
                // Note: we can't see others hand content usually, but in Firebase basic rules everyone reads everything.
                // For UI, we filter.
                isMe: id === myId
            }));

            renderOpponents();

            // 2. Control Buttons (Start for host)
            const btnStart = document.getElementById('btn-start');
            if (data.status === 'waiting') {
                if (data.host === myId) {
                    btnStart.style.display = 'block';
                    btnStart.innerText = `ÿ®ÿØÿ° ÿßŸÑŸÑÿπÿ® (${pIds.length})`;
                    btnStart.disabled = pIds.length < 2;
                } else {
                    btnStart.style.display = 'none';
                    document.getElementById('status-msg').innerText = "ÿ®ÿßŸÜÿ™ÿ∏ÿßÿ± ÿßŸÑŸÖÿ∂ŸäŸÅ ŸÑŸäÿ®ÿØÿ£...";
                }
                document.getElementById('board-content').innerHTML = '';
                document.getElementById('my-hand').innerHTML = '';
            }
            else if (data.status === 'playing') {
                btnStart.style.display = 'none';

                // Render Board
                renderBoard(data.board || []);

                // Render My Hand
                const myPlayerData = data.players[myId];
                if (myPlayerData && myPlayerData.hand) {
                    myHand = myPlayerData.hand; // Array of objects
                    renderHand();
                }

                // Turn Status
                const currentPlayerId = pIds[data.turnIndex];
                const isMyTurn = currentPlayerId === myId;

                if (isMyTurn) {
                    document.getElementById('status-msg').innerText = "üü¢ ÿØŸàÿ±ŸÉ!";
                    document.getElementById('board-area').style.borderColor = "#4caf50";
                    checkMyOptions(data);
                } else {
                    const currName = data.players[currentPlayerId].name;
                    document.getElementById('status-msg').innerText = `‚è≥ ÿØŸàÿ± ${currName}`;
                    document.getElementById('board-area').style.borderColor = "transparent";
                    disableControls();
                }

                // Market Count
                const marketCount = data.market ? data.market.length : 0;
                document.getElementById('market-cnt').innerText = marketCount;
            }
            else if (data.status === 'finished') {
                document.getElementById('status-msg').innerText = data.winMsg || "ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©";
                if (data.host === myId) {
                    btnStart.style.display = 'block';
                    btnStart.innerText = "ŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ";
                }
            }

            // Chat Sync
            if (data.chat) {
                const chatBox = document.getElementById('chat-messages');
                chatBox.innerHTML = '';
                Object.values(data.chat).forEach(msg => {
                    const d = document.createElement('div');
                    d.className = `msg ${msg.sender === myName ? 'me' : ''}`;
                    d.innerHTML = `<b>${msg.sender}</b> ${msg.text}`;
                    chatBox.appendChild(d);
                });
                chatBox.scrollTop = chatBox.scrollHeight;
            }
        }

        // --- Host Starts Game ---
        window.startGame = () => {
            // Generate Deck
            const players = Object.keys(gameData.players);
            const playerCount = players.length;
            let deck = initDeck();

            // 3 Player Rule: Remove 0|0
            if (playerCount === 3) {
                deck = deck.filter(t => !(t.v1 === 0 && t.v2 === 0));
            }

            // Shuffle
            deck.sort(() => Math.random() - 0.5);

            // Distribute
            let handSize = 7;
            if (playerCount === 3) handSize = 9;

            const updates = {};
            updates[`rooms/${currentRoom}/status`] = 'playing';
            updates[`rooms/${currentRoom}/turnIndex`] = 0; // Host or random? Let's say index 0
            updates[`rooms/${currentRoom}/board`] = [];
            updates[`rooms/${currentRoom}/chainHead`] = null;
            updates[`rooms/${currentRoom}/chainTail`] = null;

            players.forEach((pid) => {
                const hand = deck.splice(0, handSize);
                updates[`rooms/${currentRoom}/players/${pid}/hand`] = hand;
            });

            // Market / Boneyard
            updates[`rooms/${currentRoom}/market`] = deck; // Remainders

            update(ref(db), updates);
        };

        // --- Gameplay Helper Functions ---

        function initDeck() {
            let d = [];
            for (let i = 0; i <= 6; i++) {
                for (let j = i; j <= 6; j++) {
                    d.push({ v1: i, v2: j });
                }
            }
            return d;
        }

        function renderOpponents() {
            const c = document.getElementById('opponents-area');
            c.innerHTML = '';
            playerList.forEach(p => {
                if (p.isMe) return;
                const div = document.createElement('div');
                div.className = 'opponent';
                if (gameData && gameData.turnIndex >= 0) {
                    const currentTurnId = Object.keys(gameData.players)[gameData.turnIndex];
                    if (p.id === currentTurnId) div.classList.add('active');
                }

                let tilesHtml = '';
                for (let i = 0; i < p.handCount; i++) tilesHtml += '<div class="mini-tile"></div>';

                div.innerHTML = `<div>${p.name}</div><div class="opponent-tiles">${tilesHtml}</div>`;
                c.appendChild(div);
            });
        }

        const dotMap = {
            0: [], 1: ['p1'], 2: ['p2-tr', 'p2-bl'], 3: ['p2-tr', 'p1', 'p2-bl'],
            4: ['p2-tl', 'p2-tr', 'p2-bl', 'p2-br'], 5: ['p2-tl', 'p2-tr', 'p1', 'p2-bl', 'p2-br'],
            6: ['p2-tl', 'p2-tr', 'p-mid-l', 'p-mid-r', 'p2-bl', 'p2-br']
        };

        function createTileDom(v1, v2, isDouble, isHorizontal) {
            const el = document.createElement('div');
            let cls = 'tile';
            if (isHorizontal && !isDouble) cls += ' horizontal';
            if (isDouble) cls += ' double-bone';
            el.className = cls;

            // Build dots... (same as before)
            const h1 = document.createElement('div'); h1.className = 'half'; addDots(h1, v1);
            const h2 = document.createElement('div'); h2.className = 'half'; addDots(h2, v2);
            el.append(h1, h2);
            return el;
        }

        function addDots(container, val) {
            dotMap[val].forEach(c => {
                const d = document.createElement('div'); d.className = 'dot ' + c;
                container.appendChild(d);
            });
        }

        function renderBoard(board) {
            const c = document.getElementById('board-content');
            c.innerHTML = '';
            board.forEach(b => {
                // b has {v1, v2, ...}
                // orientation logic is pre-calculated or needs calculate? 
                // For simplicity, we save visualV1 and visualV2 in board state or infer it.
                // Let's assume board saves visual state: {v1, v2, isHorizontal}
                const isDouble = b.v1 === b.v2;
                const el = createTileDom(b.v1, b.v2, isDouble, true); // Always horizontal on board unless double
                c.appendChild(el);
            });
        }

        function renderHand() {
            const c = document.getElementById('my-hand');
            c.innerHTML = '';
            myHand.forEach((tile, idx) => {
                const isDouble = tile.v1 === tile.v2;
                const el = createTileDom(tile.v1, tile.v2, isDouble, false);
                el.onclick = () => playTile(idx);

                // Validation highlight
                const valid = getValidMove(tile, gameData.chainHead, gameData.chainTail);
                if (!valid && gameData.status === 'playing') el.classList.add('disabled');

                c.appendChild(el);
            });
        }

        function getValidMove(tile, head, tail) {
            // First move?
            if (head === undefined || head === null) return { side: 'start', connect: 'v1' }; // Any tile valid

            // Check Head
            if (tile.v1 === head) return { side: 'head', connect: 'v1', newExposed: tile.v2 };
            if (tile.v2 === head) return { side: 'head', connect: 'v2', newExposed: tile.v1 };

            // Check Tail
            if (tile.v1 === tail) return { side: 'tail', connect: 'v1', newExposed: tile.v2 };
            if (tile.v2 === tail) return { side: 'tail', connect: 'v2', newExposed: tile.v1 };

            return null;
        }

        // --- Player Actions ---

        window.playTile = async (index) => {
            // Check local turn
            const pIds = Object.keys(gameData.players);
            if (pIds[gameData.turnIndex] !== myId) return;

            const tile = myHand[index];
            const move = getValidMove(tile, gameData.chainHead, gameData.chainTail);

            if (!move) return alert("ÿ≠ÿ±ŸÉÿ© ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ÿ©");

            // Construct Update
            const updates = {};

            // 1. Remove from hand
            const newHand = [...myHand];
            newHand.splice(index, 1);
            updates[`rooms/${currentRoom}/players/${myId}/hand`] = newHand;

            // 2. Add to Board
            let visualV1, visualV2;
            if (move.side === 'start') {
                visualV1 = tile.v1; visualV2 = tile.v2;
                updates[`rooms/${currentRoom}/chainHead`] = tile.v1;
                updates[`rooms/${currentRoom}/chainTail`] = tile.v2;
                updates[`rooms/${currentRoom}/board`] = [{ v1: tile.v1, v2: tile.v2 }];
            }
            else if (move.side === 'tail') {
                // Append to right
                // if connect=v1, left of new tile is v1. visualV1=v1.
                if (move.connect === 'v1') { visualV1 = tile.v1; visualV2 = tile.v2; }
                else { visualV1 = tile.v2; visualV2 = tile.v1; }

                updates[`rooms/${currentRoom}/chainTail`] = move.newExposed;
                const currentBoard = gameData.board || [];
                updates[`rooms/${currentRoom}/board`] = [...currentBoard, { v1: visualV1, v2: visualV2 }];
            }
            else { // head
                // Prepend to left
                // if connect=v1, right of new tile is v1. visualV2=v1.
                if (move.connect === 'v1') { visualV1 = tile.v2; visualV2 = tile.v1; }
                else { visualV1 = tile.v1; visualV2 = tile.v2; }

                updates[`rooms/${currentRoom}/chainHead`] = move.newExposed;
                const currentBoard = gameData.board || [];
                updates[`rooms/${currentRoom}/board`] = [{ v1: visualV1, v2: visualV2 }, ...currentBoard];
            }

            // 3. Next Turn
            let nextIndex = (gameData.turnIndex + 1) % pIds.length;
            updates[`rooms/${currentRoom}/turnIndex`] = nextIndex;

            // 4. Check Win
            if (newHand.length === 0) {
                updates[`rooms/${currentRoom}/status`] = 'finished';
                updates[`rooms/${currentRoom}/winMsg`] = `ŸÅÿßÿ≤ ${myName}!`;
            }

            await update(ref(db), updates);
        };

        window.drawTile = async () => {
            if (!gameData.market || gameData.market.length === 0) return;

            const market = [...gameData.market];
            const tile = market.pop();
            const newHand = [...myHand, tile];

            const updates = {};
            updates[`rooms/${currentRoom}/market`] = market;
            updates[`rooms/${currentRoom}/players/${myId}/hand`] = newHand;

            await update(ref(db), updates);
        };

        window.passTurn = async () => {
            // Should check if really blocked
            const pIds = Object.keys(gameData.players);
            let nextIndex = (gameData.turnIndex + 1) % pIds.length;
            await update(ref(db, `rooms/${currentRoom}/turnIndex`), nextIndex);

            // TODO: Detect global block (all passed consecutively? Not implemented for simplicity)
        };

        function checkMyOptions(data) {
            const canMove = myHand.some(t => getValidMove(t, data.chainHead, data.chainTail));
            const btnDraw = document.getElementById('btn-draw');
            const btnPass = document.getElementById('btn-pass');

            // Draw button
            if (!canMove && data.market && data.market.length > 0) {
                btnDraw.disabled = false;
                // btnDraw.classList.remove('secondary'); // Style handled by disabled attr check in CSS mostly or dynamic class
                btnDraw.style.opacity = "1";
            } else {
                btnDraw.disabled = true;
                btnDraw.style.opacity = "0.5";
            }

            // Pass button
            if (!canMove && (!data.market || data.market.length === 0)) {
                btnPass.disabled = false;
                btnPass.style.opacity = "1";
            } else {
                btnPass.disabled = true;
                btnPass.style.opacity = "0.5";
            }
        }

        function disableControls() {
            document.getElementById('btn-draw').disabled = true;
            document.getElementById('btn-pass').disabled = true;
        }

        // --- Chat ---
        window.toggleChat = () => {
            document.getElementById('chat-container').classList.toggle('minimized');
        }

        window.sendMsg = () => {
            const input = document.getElementById('chat-input');
            const text = input.value.trim();
            if (!text) return;

            push(child(ref(db), `rooms/${currentRoom}/chat`), {
                sender: myName,
                text: text,
                time: Date.now()
            });
            input.value = '';
        }
    </script>
</body>

</html>
