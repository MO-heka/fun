<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HEKA LUDO MASTER</title>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0f172a;
            --glass-bg: rgba(30, 41, 59, 0.85);
            --glass-border: rgba(255, 255, 255, 0.1);
            --green: #22c55e;
            --yellow: #eab308;
            --blue: #3b82f6;
            --red: #ef4444;
            --accent: #f59e0b;
            --shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            --font-main: 'Cairo', sans-serif;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-color);
            color: white;
            font-family: var(--font-main);
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-image: radial-gradient(circle at 50% 50%, #1e293b 0%, #0f172a 100%);
            overflow: hidden;
            /* Prevent scroll */
        }

        /* Wood Texture for Board */
        .wood-texture {
            background-color: #d4a373;
            background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h20v20H0V0zm10 17a7 7 0 1 0 0-14 7 7 0 0 0 0 14zm20 0a7 7 0 1 0 0-14 7 7 0 0 0 0 14zM10 37a7 7 0 1 0 0-14 7 7 0 0 0 0 14zm10-17h20v20H20V20zm10 17a7 7 0 1 0 0-14 7 7 0 0 0 0 14z' fill='%23faedcd' fill-opacity='0.1' fill-rule='evenodd'/%3E%3C/svg%3E");
        }

        /* Screen Management */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s;
            z-index: 10;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            z-index: -1;
            display: none !important;
        }

        /* UI Components */
        .panel {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            padding: 25px;
            border-radius: 20px;
            text-align: center;
            box-shadow: var(--shadow);
            backdrop-filter: blur(10px);
            width: 90%;
            max-width: 400px;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        h1 {
            margin: 0 0 20px;
            color: var(--accent);
            font-weight: 900;
            text-shadow: 0 0 15px rgba(245, 158, 11, 0.3);
        }

        button {
            background: linear-gradient(135deg, #6366f1, #4f46e5);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 1.1rem;
            font-family: var(--font-main);
            font-weight: bold;
            margin: 10px;
            cursor: pointer;
            width: 100%;
            transition: transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px 0 #3730a3;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        button.secondary {
            background: #334155;
            box-shadow: 0 4px 0 #1e293b;
        }

        input {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border: 2px solid #334155;
            background: rgba(0, 0, 0, 0.2);
            color: white;
            font-family: var(--font-main);
            text-align: center;
            font-size: 1.2rem;
            outline: none;
        }

        input:focus {
            border-color: var(--accent);
        }

        input:focus {
            border-color: var(--accent);
        }

        .safe-spot-marker {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            opacity: 0.5;
            pointer-events: none;
        }

        /* Hit Area Boost */
        .token::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            border-radius: 50%;
            z-index: -1;
        }

        /* Game Area */
        #game-container {
            position: relative;
            width: 100vw;
            max-width: 600px;
            aspect-ratio: 1/1;
            margin: auto;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        /* SVG Board */
        #ludo-board {
            width: 100%;
            height: 100%;
            background: #fff;
            border-radius: 5px;
        }

        /* Tokens */
        .token {
            position: absolute;
            width: 6%;
            height: 6%;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 4px 5px rgba(0, 0, 0, 0.4), inset 0 -3px 5px rgba(0, 0, 0, 0.3), inset 0 3px 5px rgba(255, 255, 255, 0.4);
            transform: translate(-50%, -50%);
            transition: top 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), left 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), transform 0.1s;
            cursor: pointer;
            z-index: 100;
            /* 3D look */
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.8), transparent 20%),
                conic-gradient(from 180deg, rgba(0, 0, 0, 0.2), transparent 50%);
        }

        .token::after {
            content: '';
            position: absolute;
            top: 20%;
            left: 20%;
            right: 20%;
            bottom: 20%;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.1);
            filter: blur(2px);
        }

        .token.green {
            background-color: #00b960;
            border-color: #008f4c;
        }

        .token.yellow {
            background-color: #f1c40f;
            border-color: #d4ac0d;
        }

        .token.blue {
            background-color: #2980b9;
            border-color: #1f618d;
        }

        .token.red {
            background-color: #c0392b;
            border-color: #922b21;
        }

        /* Ghost Token for Hover */
        .ghost-token {
            position: absolute;
            width: 6%;
            height: 6%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            border: 2px dashed white;
            z-index: 90;
            opacity: 0.6;
            pointer-events: none;
            transform: translate(-50%, -50%);
            animation: pulse-ghost 1s infinite;
        }

        @keyframes pulse-ghost {
            50% {
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 0.8;
            }
        }

        .token.yellow {
            background: var(--yellow);
        }

        .token.blue {
            background: var(--blue);
        }

        .token.red {
            background: var(--red);
        }

        .token.glow {
            animation: pulse-glow 1s infinite alternate;
            z-index: 110;
            cursor: pointer;
        }

        .token.stacked-2 {
            transform: translate(-50%, -60%) scale(0.9);
        }

        /* Dice */
        #dice-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.95);
            /* Force visible bg */
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 3px solid #334155;
            /* Distinct border */
            cursor: pointer;
            transition: transform 0.1s;
            z-index: 2000;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #dice-panel.disabled {
            filter: grayscale(1);
            cursor: not-allowed;
            opacity: 0.8;
            /* Kept visible but dimmed so others see the roll */
        }

        #dice-panel:active {
            transform: scale(0.95);
        }

        #dice-cube {
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 6px;
            gap: 2px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .dot {
            background: #333;
            border-radius: 50%;
            opacity: 0;
        }

        /* Dice Dot Configurations (0=hidden, 1=visible) */
        .d-1 :nth-child(5) {
            opacity: 1;
        }

        .d-2 :nth-child(1),
        .d-2 :nth-child(9) {
            opacity: 1;
        }

        .d-3 :nth-child(1),
        .d-3 :nth-child(5),
        .d-3 :nth-child(9) {
            opacity: 1;
        }

        .d-4 :nth-child(1),
        .d-4 :nth-child(3),
        .d-4 :nth-child(7),
        .d-4 :nth-child(9) {
            opacity: 1;
        }

        .d-5 :nth-child(1),
        .d-5 :nth-child(3),
        .d-5 :nth-child(5),
        .d-5 :nth-child(7),
        .d-5 :nth-child(9) {
            opacity: 1;
        }

        .d-6 :nth-child(1),
        .d-6 :nth-child(3),
        .d-6 :nth-child(4),
        .d-6 :nth-child(6),
        .d-6 :nth-child(7),
        .d-6 :nth-child(9) {
            opacity: 1;
        }

        .rolling {
            animation: shake 0.4s infinite;
        }

        /* Player Info */
        .player-card {
            position: absolute;
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 30px;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 2px solid transparent;
            transition: 0.3s;
            font-size: 0.9rem;
        }

        .player-card img {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #333;
        }

        .player-card.active {
            border-color: var(--accent);
            background: rgba(245, 158, 11, 0.2);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.3);
        }

        .p-green {
            top: 10px;
            left: 10px;
        }

        .p-yellow {
            top: 10px;
            right: 10px;
        }

        .p-red {
            bottom: 10px;
            left: 10px;
        }

        /* Swapped standard positions for UI balance */
        .p-blue {
            bottom: 10px;
            right: 10px;
        }

        /* Notification Toast */
        #toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid var(--accent);
            z-index: 1000;
            transition: 0.3s;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #toast.show {
            transform: translateX(-50%) translateY(0);
        }

        /* Chat */
        #chat-btn {
            position: fixed;
            bottom: 120px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--blue);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 200;
            border: none;
        }

        #chat-box {
            position: fixed;
            bottom: 180px;
            right: 20px;
            width: 300px;
            height: 350px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            z-index: 201;
            transform: scale(0);
            transition: 0.2s;
            transform-origin: bottom right;
        }

        #chat-box.open {
            transform: scale(1);
        }

        .msg {
            padding: 5px 10px;
            margin: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            font-size: 0.85rem;
        }

        /* Animations */
        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes pulse-glow {
            from {
                box-shadow: 0 0 5px white;
            }

            to {
                box-shadow: 0 0 20px var(--accent);
            }
        }

        @keyframes shake {
            0% {
                transform: rotate(0deg);
            }

            25% {
                transform: rotate(10deg);
            }

            50% {
                transform: rotate(0deg);
            }

            75% {
                transform: rotate(-10deg);
            }

            100% {
                transform: rotate(0deg);
            }
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: red;
            animation: fall 3s linear forwards;
        }

        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(720deg);
            }
        }


        /* Mobile Optimization */
        @media (max-width: 600px) {
            #game-container {
                width: 96vw;
                height: 96vw;
                /* Keep square */
                margin-top: 60px;
                /* Space for top players */
            }

            .player-card {
                padding: 4px 8px;
                background: rgba(0, 0, 0, 0.8);
                font-size: 0.75rem;
            }

            .player-card img {
                width: 25px;
                height: 25px;
            }

            /* Custom Positioning for Mobile to not cover board */
            #dice-panel {
                bottom: 20px;
                right: 20px;
                left: auto;
                transform: none;
                width: 70px;
                height: 70px;
            }

            #dice-panel:active {
                transform: scale(0.95);
            }

            #chat-btn {
                bottom: 100px;
                right: 20px;
                width: 45px;
                height: 45px;
                font-size: 20px;
            }

            h1 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>

<body>

    <!-- Notification -->
    <div id="toast">üîî <span id="toast-msg"></span></div>

    <!-- MAIN MENU -->
    <div id="screen-menu" class="screen">
        <div class="panel">
            <h1>üé≤ LUDO MASTER</h1>
            <h3 id="welcome-msg" style="color: #cbd5e1; margin-bottom: 20px;"></h3>
            <button onclick="startGame('offline')">üë§ ÿ∂ÿØ ÿßŸÑŸÉŸÖÿ®ŸäŸàÿ™ÿ± (Offline)</button>
            <button onclick="showOnlineMenu()" style="background: linear-gradient(135deg, #f59e0b, #d97706);">üåê ŸÑÿπÿ®
                ÿ£ŸàŸÜŸÑÿßŸäŸÜ (Online)</button>
        </div>
    </div>

    <!-- ONLINE MENU -->
    <div id="screen-online" class="screen hidden">
        <div class="panel">
            <h2>üåç ÿßŸÑÿ£ŸàŸÜŸÑÿßŸäŸÜ</h2>

            <div style="margin-bottom: 15px;">
                <label style="display:block; margin-bottom:5px; color:#cbd5e1">ÿßÿÆÿ™ÿ± ÿ¥ŸÉŸÑŸÉ:</label>
                <div style="display:flex; justify-content:center; gap:10px;">
                    <div onclick="selectAvatar('Felix')" class="avatar-opt"
                        style="cursor:pointer; border:2px solid transparent; border-radius:50%; padding:2px;"><img
                            src="https://api.dicebear.com/7.x/avataaars/svg?seed=Felix" width="40"></div>
                    <div onclick="selectAvatar('Aneka')" class="avatar-opt"
                        style="cursor:pointer; border:2px solid transparent; border-radius:50%; padding:2px;"><img
                            src="https://api.dicebear.com/7.x/avataaars/svg?seed=Aneka" width="40"></div>
                    <div onclick="selectAvatar('Bob')" class="avatar-opt"
                        style="cursor:pointer; border:2px solid transparent; border-radius:50%; padding:2px;"><img
                            src="https://api.dicebear.com/7.x/avataaars/svg?seed=Bob" width="40"></div>
                    <div onclick="selectAvatar('Zack')" class="avatar-opt"
                        style="cursor:pointer; border:2px solid transparent; border-radius:50%; padding:2px;"><img
                            src="https://api.dicebear.com/7.x/avataaars/svg?seed=Zack" width="40"></div>
                    <div onclick="selectAvatar('Bear')" class="avatar-opt"
                        style="cursor:pointer; border:2px solid transparent; border-radius:50%; padding:2px;"><img
                            src="https://api.dicebear.com/7.x/avataaars/svg?seed=Bear" width="40"></div>
                </div>
            </div>

            <button onclick="createRoom()">‚ûï ÿ•ŸÜÿ¥ÿßÿ° ÿ∫ÿ±ŸÅÿ©</button>
            <div style="display:flex; gap: 5px; align-items: center;">
                <input id="room-code-input" placeholder="ÿßŸÉÿ™ÿ® ŸÉŸàÿØ ÿßŸÑÿ∫ÿ±ŸÅÿ©" style="margin: 0;">
                <button onclick="joinRoom()" style="width: auto; padding: 15px;">ÿØÿÆŸàŸÑ</button>
            </div>
            <button class="secondary" onclick="showScreen('screen-menu')">ÿ±ÿ¨Ÿàÿπ</button>
        </div>
    </div>

    <!-- LOBBY -->
    <div id="screen-lobby" class="screen hidden">
        <div class="panel">
            <h2>üõãÔ∏è ÿµÿßŸÑÿ© ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±</h2>
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 10px; margin: 10px 0;">
                <span style="color: #94a3b8; font-size: 0.9rem;">ŸÉŸàÿØ ÿßŸÑÿ∫ÿ±ŸÅÿ©:</span>
                <div style="font-size: 2rem; color: var(--accent); letter-spacing: 2px; font-weight: bold; cursor: pointer;"
                    onclick="copyCode()" id="lobby-code">---</div>
                <div style="font-size: 0.8rem; color: #64748b;">(ÿßÿ∂ÿ∫ÿ∑ ŸÑŸÑŸÜÿ≥ÿÆ)</div>
            </div>
            <div id="lobby-players" style="text-align: right; min-height: 100px;">
                <!-- Player List -->
            </div>
            <button id="start-btn" class="hidden" onclick="startOnlineGame()">üöÄ ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®</button>
            <button class="secondary" onclick="leaveRoom()">ÿÆÿ±Ÿàÿ¨</button>
        </div>
    </div>

    <!-- GAME AREA -->
    <div id="screen-game" class="screen hidden">
        <!-- Player Stats (Mobile Optimized) -->
        <div class="player-card" id="p-card-0" style="top:5px; left:5px;">
            <img src="https://api.dicebear.com/7.x/avataaars/svg?seed= Felix">
            <div class="p-info"><span class="p-name">Player 1</span></div>
        </div>
        <div class="player-card" id="p-card-1" style="top:5px; right:5px; flex-direction: row-reverse;">
            <img src="https://api.dicebear.com/7.x/avataaars/svg?seed=Aneka">
            <div class="p-info"><span class="p-name">Player 2</span></div>
        </div>
        <div class="player-card" id="p-card-2" style="bottom:100px; right:5px; flex-direction: row-reverse;">
            <div class="p-info"><span class="p-name">Player 3</span></div> <img
                src="https://api.dicebear.com/7.x/avataaars/svg?seed=Bob">
        </div>
        <div class="player-card" id="p-card-3" style="bottom:100px; left:5px;">
            <img src="https://api.dicebear.com/7.x/avataaars/svg?seed=Zack">
            <div class="p-info"><span class="p-name">Player 4</span></div>
        </div>

        <!-- The Board -->
        <div id="game-container">
            <svg id="ludo-board" viewBox="0 0 1500 1500">
                <!-- Defs -->
                <defs>
                    <pattern id="star" x="0" y="0" width="1" height="1">
                        <polygon points="50,5 20,90 95,30 5,30 80,90" fill="rgba(0,0,0,0.2)" />
                    </pattern>
                </defs>
                <!-- Background -->
                <rect width="1500" height="1500" fill="#f8f9fa" rx="20" /> <!-- Clean White/Grey Base -->

                <!-- Wood Frame -->
                <rect x="0" y="0" width="1500" height="1500" rx="20" fill="none" stroke="#5d4037" stroke-width="30" />

                <!-- Bases -->
                <!-- Bases (Colors Adjusted: G=TL, Y=TR, B=BR, R=BL) -->
                <rect x="0" y="0" width="600" height="600" fill="#22c55e" /> <!-- Green TL -->
                <rect x="900" y="0" width="600" height="600" fill="#eab308" /> <!-- Yellow TR -->
                <rect x="900" y="900" width="600" height="600" fill="#3b82f6" /> <!-- Blue BR -->
                <rect x="0" y="900" width="600" height="600" fill="#ef4444" /> <!-- Red BL -->

                <!-- Inner Whites -->
                <rect x="100" y="100" width="400" height="400" fill="white" rx="40" />
                <rect x="1000" y="100" width="400" height="400" fill="white" rx="40" />
                <rect x="1000" y="1000" width="400" height="400" fill="white" rx="40" />
                <rect x="100" y="1000" width="400" height="400" fill="white" rx="40" />

                <!-- Center Triangle Colors (Match Arms) -->
                <!-- Top (Yellow), Right (Blue), Bottom (Red), Left (Green) -->
                <polygon points="600,600 900,600 750,750" fill="#eab308" opacity="0.8" /> <!-- Top -->
                <polygon points="900,600 900,900 750,750" fill="#3b82f6" opacity="0.8" /> <!-- Right -->
                <polygon points="900,900 600,900 750,750" fill="#ef4444" opacity="0.8" /> <!-- Bottom -->
                <polygon points="600,900 600,600 750,750" fill="#22c55e" opacity="0.8" /> <!-- Left -->

                <!-- Tracks -->
                <g id="grid-lines" stroke="#ccc" stroke-width="2">
                    <!-- ... existing lines ... -->
                    <line x1="600" y1="0" x2="600" y2="1500" />
                    <line x1="700" y1="0" x2="700" y2="600" />
                    <line x1="800" y1="0" x2="800" y2="600" />
                    <line x1="700" y1="900" x2="700" y2="1500" />
                    <line x1="800" y1="900" x2="800" y2="1500" />
                    <line x1="900" y1="0" x2="900" y2="1500" />
                    <line x1="0" y1="600" x2="1500" y2="600" />
                    <line x1="0" y1="700" x2="600" y2="700" />
                    <line x1="0" y1="800" x2="600" y2="800" />
                    <line x1="900" y1="700" x2="1500" y2="700" />
                    <line x1="900" y1="800" x2="1500" y2="800" />
                    <line x1="0" y1="900" x2="1500" y2="900" />
                    <path d="M600 100 H900 M600 200 H900 M600 300 H900 M600 400 H900 M600 500 H900" />
                    <path d="M600 1000 H900 M600 1100 H900 M600 1200 H900 M600 1300 H900 M600 1400 H900" />
                    <path d="M100 600 V900 M200 600 V900 M300 600 V900 M400 600 V900 M500 600 V900" />
                    <path d="M1000 600 V900 M1100 600 V900 M1200 600 V900 M1300 600 V900 M1400 600 V900" />
                </g>

                <!-- Home Runs Colors Corrected -->
                <!-- Top: Yellow -->
                <rect x="700" y="100" width="100" height="500" fill="#eab308" opacity="0.4" />
                <!-- Right: Blue -->
                <rect x="900" y="700" width="500" height="100" fill="#3b82f6" opacity="0.4" />
                <!-- Bottom: Red -->
                <rect x="700" y="900" width="100" height="500" fill="#ef4444" opacity="0.4" />
                <!-- Left: Green -->
                <rect x="100" y="700" width="500" height="100" fill="#22c55e" opacity="0.4" />

                <!-- Safe Spots (Darkened Cells) -->
                <defs>
                    <g id="safe-cell">
                        <rect x="0" y="0" width="100" height="100" fill="#0f172a" opacity="0.8" />
                        <text x="50" y="70" font-size="50" text-anchor="middle" fill="#64748b">üõ°Ô∏è</text>
                    </g>
                </defs>

                <!-- Base Safe Exits (Colored Start Squares) -->
                <!-- Green Start (Left): x100 y600 -->
                <rect x="100" y="600" width="100" height="100" fill="#22c55e" opacity="0.5" />
                <!-- Yellow Start (Top): x800 y100 -->
                <rect x="800" y="100" width="100" height="100" fill="#eab308" opacity="0.5" />
                <!-- Blue Start (Right): x1300 y800 -->
                <rect x="1300" y="800" width="100" height="100" fill="#3b82f6" opacity="0.5" />
                <!-- Red Start (Bottom): x600 y1300 -->
                <rect x="600" y="1300" width="100" height="100" fill="#ef4444" opacity="0.5" />

                <!-- Shared Safe Spots (All Shields) -->
                <!-- Star Positions (Safe) -->
                <use href="#safe-cell" x="600" y="200" /> <!-- Top L -->
                <use href="#safe-cell" x="1200" y="600" /> <!-- Right T -->
                <use href="#safe-cell" x="800" y="1200" /> <!-- Bottom R -->
                <use href="#safe-cell" x="200" y="800" /> <!-- Left B -->

                <!-- Start Positions (Safe Shields too according to request) -->
                <use href="#safe-cell" x="100" y="600" /> <!-- Green Start -->
                <use href="#safe-cell" x="800" y="100" /> <!-- Yellow Start -->
                <use href="#safe-cell" x="1300" y="800" /> <!-- Blue Start -->
                <use href="#safe-cell" x="600" y="1300" /> <!-- Red Start -->
            </svg>

            <!-- Tokens & Ghosts -->
            <div id="ghost-layer"></div>
            <div id="tokens-layer"></div>

            <!-- Turn Indicator Overlay on Center -->
            <div id="turn-indicator" style="position: absolute; top:50%; left:50%; transform:translate(-50%,-50%); 
                 width:100px; height:100px; pointer-events:none; border-radius:50%; 
                 border: 5px solid transparent; transition:border-color 0.3s; z-index:50;"></div>
        </div>

        <!-- Controls -->
        <!-- Dice is now always visible but disabled when not your turn -->
        <div id="dice-panel" class="" onclick="requestRoll()">
            <div id="dice-cube" class="d-6">
                <!-- 3D Transform faces would be better, but flat for now with polish -->
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
            </div>
            <div id="dice-msg"
                style="position: absolute; bottom: -30px; font-weight: bold; font-size: 0.8rem; width: 120px; text-align: center; color:var(--accent); text-shadow:0 1px 2px black;">
                ÿßÿ∂ÿ∫ÿ∑ ŸÑŸÑÿ±ŸÖŸä
            </div>
        </div>

        <button id="chat-btn" onclick="toggleChat()">üí¨</button>
        <div id="chat-box" class="hidden">
            <div
                style="padding: 10px; background: var(--accent); color: black; font-weight: bold; border-radius: 12px 12px 0 0; display:flex; justify-content:space-between;">
                <span>ÿ¥ÿßÿ™ ÿßŸÑÿ∫ÿ±ŸÅÿ©</span> <span onclick="toggleChat()">‚úñ</span>
            </div>
            <div id="chat-msgs" style="flex: 1; overflow-y: auto; padding: 10px;"></div>
            <div style="display: flex; padding: 5px;">
                <input id="chat-input" placeholder="ÿßŸÉÿ™ÿ®..." style="margin: 0; flex:1">
                <button onclick="sendChat()" style="width: auto; padding: 0 15px; margin: 0 5px;">‚û§</button>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIG & UTILS ---
        // --- CONFIG & UTILS ---
        const colors = ['green', 'yellow', 'blue', 'red'];

        // Firebase Configuration (Required for Online/Offline DB calls if any)
        const firebaseConfig = {
            apiKey: "AIzaSyCp9_P3K__Sr76iKgaVG1iD4NluUqPtni4",
            authDomain: "heka-codenames.firebaseapp.com",
            projectId: "heka-codenames",
            storageBucket: "heka-codenames.firebasestorage.app",
            messagingSenderId: "901713932504",
            appId: "1:901713932504:web:7079662022a501e9c4e7ad",
            databaseURL: "https://heka-codenames-default-rtdb.firebaseio.com"
        };
        if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        let gameState = {
            turn: 0,
            dice: 0,
            tokens: [[-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]], // 0:green, 1:yellow, 2:blue, 3:red
            lastMove: null,
            finished: [false, false, false, false],
            players: []
        };

        let myName = localStorage.getItem('heka_global_player_name') || "Player";
        let myId = Math.random().toString(36).substr(2, 9);
        let myAvatar = 'Felix';
        let currentRoom = null;
        let playMode = 'offline'; // offline, online
        let myColorIndex = 0; // if online
        let diceAnimInterval;
        let isRolling = false;

        // --- SOUNDS ---
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        const ctx = new AudioCtx();
        function playTone(freq, type = 'sine', dur = 0.1) {
            if (ctx.state === 'suspended') ctx.resume();
            const o = ctx.createOscillator(); const g = ctx.createGain();
            o.type = type; o.frequency.value = freq;
            o.connect(g); g.connect(ctx.destination);
            o.start(); g.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + dur);
            o.stop(ctx.currentTime + dur);
        }
        const sfx = {
            move: () => playTone(300, 'triangle', 0.1),
            dice: () => playTone(400, 'square', 0.05),
            kill: () => { playTone(150, 'sawtooth', 0.2); setTimeout(() => playTone(100, 'sawtooth', 0.4), 100); },
            win: () => { playTone(500, 'sine', 0.2); setTimeout(() => playTone(800, 'square', 0.4), 200); }
        };

        // --- INIT ---
        window.onload = () => {
            document.getElementById('welcome-msg').innerText = "ŸÖÿ±ÿ≠ÿ®ÿßŸã " + myName;
            renderTokens();
        };

        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById(id).classList.remove('hidden');
        }

        // --- NAVIGATION ---
        function startGame(mode) {
            playMode = mode;
            if (mode === 'offline') {
                myColorIndex = 0;
                gameState.players = [
                    { n: myName, id: 'me', avatar: myAvatar },
                    { n: 'Bot 1', id: 'bot', avatar: 'Felix' },
                    { n: 'Bot 2', id: 'bot', avatar: 'Bear' },
                    { n: 'Bot 3', id: 'bot', avatar: 'Zack' }
                ];
                gameState.turn = 0;
                resetBoard();
                showScreen('screen-game');
                updateUI();
            }
        }

        function showOnlineMenu() { showScreen('screen-online'); }

        // --- ONLINE LOGIC ---
        function createRoom() {
            const code = Math.floor(1000 + Math.random() * 9000).toString();
            db.ref('ludo_rooms/' + code).set({
                players: [{ name: myName, id: myId, color: 0, avatar: myAvatar }],
                turn: 0,
                dice: 0,
                tokens: gameState.tokens,
                status: 'waiting'
            });
            enterLobby(code, 0);
        }

        function joinRoom() {
            const code = document.getElementById('room-code-input').value;
            db.ref('ludo_rooms/' + code).once('value', s => {
                if (!s.exists()) return toast('ÿßŸÑÿ∫ÿ±ŸÅÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©');
                const d = s.val();
                if (d.status !== 'waiting') return toast('ÿßŸÑŸÑÿπÿ®ÿ© ÿ®ÿØÿ£ÿ™ ÿ®ÿßŸÑŸÅÿπŸÑ');
                if (d.players.length >= 4) return toast('ÿßŸÑÿ∫ÿ±ŸÅÿ© ŸÖŸÖÿ™ŸÑÿ¶ÿ©');

                const color = d.players.length;
                d.players.push({ name: myName, id: myId, color: color, avatar: myAvatar });
                db.ref('ludo_rooms/' + code).update({ players: d.players });
                enterLobby(code, color);
            });
        }

        function enterLobby(code, color) {
            currentRoom = code;
            myColorIndex = color;
            playMode = 'online';
            showScreen('screen-lobby');
            document.getElementById('lobby-code').innerText = code;

            db.ref('ludo_rooms/' + currentRoom).on('value', snap => {
                const val = snap.val();
                if (!val) return location.reload();

                // Lobby Update
                const pList = document.getElementById('lobby-players');
                pList.innerHTML = val.players.map(p => `
                    <div style="display:flex; align-items:center; justify-content:flex-end; gap:8px; margin:5px 0;">
                        <span style="font-weight:bold">${p.name}</span>
                        <img src="https://api.dicebear.com/7.x/avataaars/svg?seed=${p.avatar || 'Felix'}" width="30" style="border-radius:50%; background:#333;">
                        <span class="d-dot" style="background:${getHexColor(p.color)}; width:10px; height:10px; display:inline-block; border-radius:50%"></span>
                    </div>`).join('');

                if (val.players[0].id === myId) document.getElementById('start-btn').classList.remove('hidden');

                // Game Start Trigger
                if (val.status === 'playing') {
                    gameState = val;
                    if (document.getElementById('screen-game').classList.contains('hidden')) {
                        showScreen('screen-game');
                    }

                    // Dice Animation Sync (Optional refinement)
                    // If server dice changes and it's not 0, show it
                    if (gameState.dice > 0 && !isRolling) {
                        renderDice(gameState.dice);
                    }

                    updateUI();
                }
            });
        }

        function startOnlineGame() {
            db.ref('ludo_rooms/' + currentRoom).update({ status: 'playing' });
        }

        function updateOnlineState(updates) {
            if (playMode === 'online') {
                db.ref('ludo_rooms/' + currentRoom).update(updates);
            }
        }

        // --- GAME LOGIC CORES ---
        function resetBoard() {
            gameState.tokens = [[-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]];
            renderTokens();
        }

        function getHexColor(i) {
            return ['#22c55e', '#eab308', '#3b82f6', '#ef4444'][i];
        }

        function updateUI() {
            // Update Active Player Card
            document.querySelectorAll('.player-card').forEach((c, i) => {
                c.classList.toggle('active', i === gameState.turn);
                const p = gameState.players[i] || {};
                c.querySelector('.p-name').innerText = p.name || '---';
                if (p.avatar) c.querySelector('img').src = `https://api.dicebear.com/7.x/avataaars/svg?seed=${p.avatar}`;
                c.style.opacity = p.name ? 1 : 0.5;
            });

            // Update Dice Interaction State
            const isMyTurn = (playMode === 'online') ? (gameState.turn === myColorIndex) : (gameState.turn === 0);
            updateDiceState(isMyTurn && gameState.dice === 0 && !isRolling);

            // Render Tokens
            renderTokens();

            // Dice
            if (!isRolling) renderDice(gameState.dice || 1);
        }

        function updateDiceState(canRoll) {
            const p = document.getElementById('dice-panel');
            const m = document.getElementById('dice-msg');
            if (canRoll) {
                p.classList.remove('disabled');
                p.style.pointerEvents = 'auto';
                m.innerText = "ÿØŸàÿ±ŸÉ! ÿßÿ∂ÿ∫ÿ∑ ŸÑŸÑÿ±ŸÖŸä";
            } else {
                p.classList.add('disabled');
                p.style.pointerEvents = 'none';

                // Show who is playing
                const currentP = gameState.players[gameState.turn];
                if (currentP) {
                    m.innerText = (gameState.turn === myColorIndex || (playMode === 'offline' && gameState.turn === 0)) ? "ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ±ŸÖŸä..." : `ÿØŸàÿ± ${currentP.name}`;
                }
            }
        }

        function renderDice(val) {
            if (val === 0) val = 1; // Default look
            const d = document.getElementById('dice-cube');
            d.className = 'd-' + val;
            d.classList.remove('rolling');
        }

        // Removed setDiceVisible as we now use Disabled class

        function selectAvatar(seed) {
            myAvatar = seed;
            document.querySelectorAll('.avatar-opt').forEach(d => d.style.borderColor = 'transparent');
            event.currentTarget.style.borderColor = 'var(--accent)';
        }

        function requestRoll() {
            if (isRolling) return;
            // Additional check: valid turn?
            if (playMode === 'online' && gameState.turn !== myColorIndex) return;
            if (playMode === 'offline' && gameState.turn !== 0) return;

            performRoll();
        }

        function performRoll() {
            isRolling = true;
            const btn = document.getElementById('dice-panel');
            document.getElementById('dice-cube').classList.add('rolling');
            document.getElementById('dice-msg').innerText = "üé≤ ...";
            sfx.dice();

            // Send "Rolling" status online ? Simplified: just local, result syncs

            setTimeout(() => {
                const roll = Math.floor(Math.random() * 6) + 1;
                isRolling = false;

                gameState.dice = roll;

                if (playMode === 'online') {
                    updateOnlineState({ dice: roll });
                } else {
                    handleRollResult(roll);
                }

                renderDice(roll);
                updateUI(); // Refresh UI state based on new dice
            }, 600);
        }

        function handleRollResult(roll) {
            // Check movable tokens
            const playerId = gameState.turn;
            const pieces = gameState.tokens[playerId];
            const moveables = pieces.map((pos, idx) => canMove(playerId, idx, roll) ? idx : -1).filter(i => i !== -1);

            if (moveables.length === 0) {
                // No move possible
                toast('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ≠ÿ±ŸÉÿßÿ™ ŸÖÿ™ÿßÿ≠ÿ©');
                setTimeout(nextTurn, 1000);
            } else if (moveables.length === 1 && playMode !== 'online') { // Auto move single option in offline
                // Wait a bit for visual
                setTimeout(() => moveToken(playerId, moveables[0]), 500);
            } else {
                // Highlight options
                moveables.forEach(idx => {
                    const el = document.getElementById(`t-${playerId}-${idx}`);
                    if (el) el.classList.add('glow');
                });

                // If offline AI
                if (playMode === 'offline' && gameState.turn !== 0) {
                    setTimeout(() => runAI(moveables), 800);
                }
            }
        }

        function runAI(options) {
            // Simple AI: Prioritize Capture > Home > Start > Advance
            // Just random for now to keep it simple but functional
            const pick = options[Math.floor(Math.random() * options.length)];
            moveToken(gameState.turn, pick);
        }

        // --- GAME LOGIC ---
        function canMove(pid, tid, roll) {
            const pos = gameState.tokens[pid][tid];
            if (pos === -1) return (roll === 6);
            if (pos >= 100) return false;
            // Goal Logic (Standard 57 limit: 0-51 common, 52-56 home, 57 goal)
            if (pos === 57) return false;
            if (pos + roll > 57) return false;
            return true;
        }

        function toGlobal(pid, localPos) {
            // 52 Common Steps Logic
            if (localPos >= 52) return -1;
            const globalStartOffset = pid * 13;
            return (globalStartOffset + localPos) % 52;
        }

        function isSafe(globalPos) {
            // 52-track Safe Spots (Offsets: Start +0, Star +8)
            // Green: 0, 8
            // Yellow: 13, 21
            // Blue: 26, 34
            // Red: 39, 47
            const safes = [0, 8, 13, 21, 26, 34, 39, 47];
            return safes.includes(globalPos);
        }

        function moveToken(pid, tid) {
            if (isProcessingMove) return;
            isProcessingMove = true;

            document.querySelectorAll('.glow').forEach(e => e.classList.remove('glow'));
            document.querySelectorAll('.token').forEach(e => e.style.animation = '');

            const roll = gameState.dice;
            let currentLocal = gameState.tokens[pid][tid];
            let previousState = currentLocal;

            if (currentLocal === -1) {
                currentLocal = 0;
                sfx.move();
            } else {
                currentLocal += roll;
                sfx.move();
            }

            gameState.tokens[pid][tid] = currentLocal;

            // Check Interactions
            if (currentLocal < 52) { // Shared Track
                const myGlobal = toGlobal(pid, currentLocal);
                if (myGlobal !== -1) {
                    // Interaction Logic:
                    // 1. Board Safe Spots (Stars/Start): No killing ever. Coexist.
                    // 2. Not Safe Spot:
                    //    - Check each opponent color.
                    //    - If Opponent has > 1 token: PROTECTED (Safe Stack). Do not kill. Coexist.
                    //    - If Opponent has 1 token: VULNERABLE. Kill.
                    //    - This allows killing multiple single tokens (e.g. killing a Green and a Red at once).

                    if (!isSafe(myGlobal)) {
                        let killedAny = false;

                        for (let op = 0; op < 4; op++) {
                            if (op === pid) continue;

                            let opTokensOnCell = [];
                            gameState.tokens[op].forEach((opos, oid) => {
                                if (opos !== -1 && opos < 52 && toGlobal(op, opos) === myGlobal) {
                                    opTokensOnCell.push(oid);
                                }
                            });

                            if (opTokensOnCell.length === 1) {
                                // Vulnerable Single Token -> KILL
                                const targetTid = opTokensOnCell[0];
                                gameState.tokens[op][targetTid] = -1; // Send to base
                                killedAny = true;
                            }
                            // If length > 1 -> Protected. Do nothing.
                        }

                        if (killedAny) {
                            sfx.kill();
                            toast(`üí• ÿ£ŸÉŸÑÿ™ ÿßŸÑŸÖŸÜÿßŸÅÿ≥!`);
                            showConfetti(5);
                        }
                    }
                }
            }

            if (currentLocal >= 57) { // Goal
                currentLocal = 57;
                gameState.tokens[pid][tid] = 57;
                checkWin(pid);
            }

            renderTokens();

            setTimeout(() => isProcessingMove = false, 500);

            if (roll === 6 || currentLocal === 57) {
                if (currentLocal === 57 && !gameState.finished[pid]) {
                    toast("ŸàÿµŸÑÿ™! üèÅ ÿßŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ");
                } else if (roll === 6) {
                    toast("ŸÑÿØŸäŸÉ ŸÑŸÅÿ© ÿ•ÿ∂ÿßŸÅŸäÿ©! üé≤");
                }
                if (gameState.finished[pid]) {
                    nextTurn();
                    return;
                }
                gameState.dice = 0;
                if (playMode === 'online') updateOnlineState(gameState);
                else {
                    updateUI();
                    if (playMode === 'offline' && gameState.turn !== 0) {
                        setTimeout(() => performRoll(), 1500);
                    }
                }
            } else {
                nextTurn();
            }
        }

        function checkWin(pid) {
            const allHome = gameState.tokens[pid].every(t => t >= 57);
            if (allHome && !gameState.finished[pid]) {
                gameState.finished[pid] = true;
                toast(`üèÜ ${gameState.players[pid].name} Wins!`);
                sfx.win();
                showConfetti(50);
            }
        }

        function nextTurn() {
            gameState.dice = 0;
            let checks = 0;
            do {
                gameState.turn = (gameState.turn + 1) % 4;
                checks++;
            } while (gameState.finished[gameState.turn] && checks < 4);

            if (playMode === 'online') {
                updateOnlineState(gameState);
            } else {
                updateUI();
                if (gameState.turn !== 0 && !gameState.finished[gameState.turn]) {
                    setTimeout(() => performRoll(), 1000);
                }
            }
        }

        // --- RENDER ---
        function renderTokens() {
            const layer = document.getElementById('tokens-layer');
            const ghostLayer = document.getElementById('ghost-layer');
            layer.innerHTML = "";
            ghostLayer.innerHTML = "";

            const map = {};
            for (let p = 0; p < 4; p++) {
                gameState.tokens[p].forEach((pos, tId) => {
                    const xy = getCoordinates(p, pos, tId);
                    const key = Math.round(xy.x) + "," + Math.round(xy.y);
                    if (!map[key]) map[key] = [];
                    map[key].push({ p, tId });
                });
            }

            // Draw
            for (let key in map) {
                const stack = map[key];
                stack.sort((a, b) => (a.p - b.p) || (a.tId - b.tId));

                stack.forEach((d, i) => {
                    const xy = key.split(',');
                    const el = document.createElement('div');
                    el.className = `token ${colors[d.p]}`;
                    el.id = `t-${d.p}-${d.tId}`;

                    let offX = 0, offY = 0;
                    if (stack.length > 1) {
                        const angle = (i / stack.length) * Math.PI * 2;
                        const dist = 14;
                        offX = Math.cos(angle) * dist;
                        offY = Math.sin(angle) * dist;
                    }

                    el.style.left = (parseFloat(xy[0]) + offX) + 'px';
                    el.style.top = (parseFloat(xy[1]) + offY) + 'px';

                    el.onclick = (e) => {
                        e.stopPropagation();
                        e.preventDefault();

                        if (playMode === 'online' && gameState.turn !== myColorIndex) return toast("ŸÑŸäÿ≥ ÿØŸàÿ±ŸÉ!");
                        if (playMode === 'offline' && gameState.turn !== 0 && d.p !== 0) return;
                        if (gameState.dice === 0 || isRolling) return toast("ÿßÿ±ŸÖŸê ÿßŸÑŸÜÿ±ÿØ ÿ£ŸàŸÑÿßŸã!");
                        if (d.p !== gameState.turn) return toast("Ÿáÿ∞Ÿá ŸÑŸäÿ≥ÿ™ ŸÇÿ∑ÿπÿ™ŸÉ!");

                        if (canMove(d.p, d.tId, gameState.dice)) {
                            moveToken(d.p, d.tId);
                        } else {
                            const pos = gameState.tokens[d.p][d.tId];
                            if (pos === -1 && gameState.dice !== 6) toast("ÿ™ÿ≠ÿ™ÿßÿ¨ 6 ŸÑŸÑÿÆÿ±Ÿàÿ¨! üé≤");
                            else toast("ÿ≠ÿ±ŸÉÿ© ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ÿ©!");
                        }
                    };

                    const myTurn = (playMode === 'online' ? gameState.turn === myColorIndex : gameState.turn === 0);
                    const canM = (myTurn && !isRolling && gameState.dice > 0 && d.p === gameState.turn && canMove(d.p, d.tId, gameState.dice));

                    if (canM) {
                        el.style.cursor = "pointer";
                        el.classList.add('glow');
                        el.style.zIndex = 999;
                        el.onmouseenter = () => showGhost(d.p, gameState.tokens[d.p][d.tId], gameState.dice);
                        el.onmouseleave = () => ghostLayer.innerHTML = "";
                    } else {
                        el.style.cursor = "default";
                        el.style.zIndex = 200 + i;
                    }

                    layer.appendChild(el);
                });
            }
        }

        function showGhost(pid, currentPos, roll) {
            if (roll === 0) return;
            let nextPos = (currentPos === -1) ? 0 : currentPos + roll;
            if (nextPos > 57) return;

            const xy = getCoordinates(pid, nextPos, 0);
            const g = document.createElement('div');
            g.className = 'ghost-token';
            g.style.left = xy.x + 'px';
            g.style.top = xy.y + 'px';
            document.getElementById('ghost-layer').appendChild(g);
        }

        function getCoordinates(pid, pos, tokenIndex) {
            const bases = [
                [[180, 180], [320, 180], [180, 320], [320, 320]],
                [[1080, 180], [1220, 180], [1080, 320], [1220, 320]],
                [[1080, 1080], [1220, 1080], [1080, 1220], [1220, 1220]],
                [[180, 1080], [320, 1080], [180, 1220], [320, 1220]]
            ];

            if (pos === -1) {
                const b = bases[pid][tokenIndex];
                const wrapper = document.getElementById('game-container').offsetWidth;
                const px = (b[0] / 1500) * 100;
                const py = (b[1] / 1500) * 100;
                return { x: px * (wrapper / 100), y: py * (wrapper / 100) };
            }

            if (pos >= 57) {
                const wrapper = document.getElementById('game-container').offsetWidth;
                const center = wrapper / 2;
                const offset = wrapper * 0.05;
                if (pid === 0) return { x: center - offset, y: center - offset };
                if (pid === 1) return { x: center + offset, y: center - offset };
                if (pid === 2) return { x: center + offset, y: center + offset };
                if (pid === 3) return { x: center - offset, y: center + offset };
                return { x: center, y: center };
            }

            const track = getPathForPlayer(pid);
            if (pos < track.length) {
                const pt = track[pos];
                const sx = (pt[0] * 100 + 50);
                const sy = (pt[1] * 100 + 50);
                const wrapper = document.getElementById('game-container').offsetWidth;
                return { x: (sx / 1500) * wrapper, y: (sy / 1500) * wrapper };
            }
            return { x: 0, y: 0 };
        }

        function getPathForPlayer(pid) {
            // Standard 52-Square Track (6-6-1 per quadrant)
            const p = [];

            // Run 1 (Right): (0,6)..(5,6) [6 steps]
            for (let i = 0; i <= 5; i++) p.push([i, 6]);
            // Run 2 (Up): (6,5)..(6,0) [6 steps]
            for (let i = 5; i >= 0; i--) p.push([6, i]);
            // Turn Top: (7,0) [1 step]
            p.push([7, 0]);

            // Q2: (8,0)..(8,5) [6], (9,6)..(14,6) [6], (14,7) [1]
            for (let i = 0; i <= 5; i++) p.push([8, i]);
            for (let i = 9; i <= 14; i++) p.push([i, 6]);
            p.push([14, 7]);

            // Q3: (14,8)..(9,8) [6], (8,9)..(8,14) [6], (7,14) [1]
            for (let i = 14; i >= 9; i--) p.push([i, 8]);
            for (let i = 9; i <= 14; i++) p.push([8, i]);
            p.push([7, 14]);

            // Q4: (6,14)..(6,9) [6], (5,8)..(0,8) [6], (0,7) [1]
            for (let i = 14; i >= 9; i--) p.push([6, i]);
            for (let i = 5; i >= 0; i--) p.push([i, 8]);
            p.push([0, 7]);

            // Home (52-56): (1,7)..(5,7) [5]
            for (let i = 1; i <= 5; i++) p.push([i, 7]);
            // Goal (57): (7,7)
            p.push([7, 7]);

            const angle = (Math.PI / 2) * pid;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);

            return p.map(pt => {
                const x = pt[0] - 7;
                const y = pt[1] - 7;
                const rx = Math.round(x * cos - y * sin + 7);
                const ry = Math.round(x * sin + y * cos + 7);
                return [rx, ry];
            });
        }

        // --- DICE HELPER ---
        function updateDiceState(canRoll) {
            const p = document.getElementById('dice-panel');
            const m = document.getElementById('dice-msg');
            if (canRoll) {
                p.classList.remove('disabled');
                p.style.pointerEvents = 'auto';
                m.innerText = "ÿØŸàÿ±ŸÉ! ÿßÿ∂ÿ∫ÿ∑ ŸÑŸÑÿ±ŸÖŸä";
            } else {
                p.classList.add('disabled');
                p.style.pointerEvents = 'none';

                const currentP = gameState.players[gameState.turn];
                if (currentP) {
                    m.innerText = (gameState.turn === myColorIndex || (playMode === 'offline' && gameState.turn === 0)) ? "ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ±ŸÖŸä..." : `ÿØŸàÿ± ${currentP.name}`;
                }
            }
        }

        function renderDice(val) {
            if (val === 0) val = 1;
            const d = document.getElementById('dice-cube');
            d.className = 'd-' + val;
            d.classList.remove('rolling');
        }

        function requestRoll() {
            if (isRolling) return;
            if (gameState.finished[gameState.turn]) {
                toast("ŸÑŸÇÿØ ÿ£ŸÜŸáŸäÿ™ ÿßŸÑŸÑÿπÿ®ÿ©! üèÜ");
                return;
            }
            if (playMode === 'online' && gameState.turn !== myColorIndex) return;
            if (playMode === 'offline' && gameState.turn !== 0) return;

            performRoll();
        }

        function performRoll() {
            isRolling = true;
            const btn = document.getElementById('dice-panel');
            document.getElementById('dice-cube').classList.add('rolling');
            document.getElementById('dice-msg').innerText = "üé≤ ...";
            sfx.dice();

            setTimeout(() => {
                const roll = Math.floor(Math.random() * 6) + 1;
                isRolling = false;

                gameState.dice = roll;

                if (playMode === 'online') {
                    updateOnlineState({ dice: roll });
                } else {
                    handleRollResult(roll);
                }

                renderDice(roll);
                updateUI();
            }, 600);
        }

        function handleRollResult(roll) {
            const playerId = gameState.turn;
            const pieces = gameState.tokens[playerId];
            // Fix: Check move logic
            const moveables = pieces.map((pos, idx) => canMove(playerId, idx, roll) ? idx : -1).filter(i => i !== -1);

            if (moveables.length === 0) {
                toast('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ≠ÿ±ŸÉÿßÿ™ ŸÖÿ™ÿßÿ≠ÿ©');
                setTimeout(nextTurn, 1000);
            } else if (moveables.length === 1 && playMode === 'offline' && gameState.turn === 0) {
                // Auto move for player if only 1 option (Convenience)
                const targetIdx = moveables[0];
                setTimeout(() => moveToken(playerId, targetIdx), 500);
            } else if (playMode === 'offline' && gameState.turn !== 0) {
                // AI always auto
                setTimeout(() => runAI(moveables), 800);
            } else {
                // Highlight for Player
                // Ensure UI is updated so tokens exist
                renderTokens();
                moveables.forEach(idx => {
                    // Try to find element
                    // We must wait for render completion or use timeout? No renderTokens is sync dom.
                    const el = document.getElementById(`t-${playerId}-${idx}`);
                    if (el) {
                        el.classList.add('glow');
                        el.style.animation = 'pulse-glow 0.8s infinite alternate';
                        // Force re-attach click if needed? renderTokens handles it.
                    }
                });
            }
        }

        // --- MOVEMENT SYSTEM ---
        // Ludo Layout:
        // 52 common cells on the perimeter.
        // Each color has a starting offset in the common loop.
        // Green: Starts at 0.
        // Yellow: Starts at 13.
        // Blue: Starts at 26.
        // Red: Starts at 39.

        // Logic:
        // State -1 = Base.
        // State 0-51 = Common Track (absolute index).
        // State 100+ = Home Stretch (100 = First square, 105 = Goal).
        // Wait, overlapping is tricky.
        // Better State:
        // LOCAL position 0-57. 0 = Start Square. 51 = Entry to home. 52-56 = Home column. 57 = Goal.
        // Convert LOCAL to GLOBAL for collision.

        function moveToken(pid, tid) {
            if (isProcessingMove) return;
            isProcessingMove = true; // Lock

            // Clear glows
            document.querySelectorAll('.glow').forEach(e => e.classList.remove('glow'));
            document.querySelectorAll('.token').forEach(e => e.style.animation = ''); // Clear pulse-glow

            const roll = gameState.dice;
            let currentLocal = gameState.tokens[pid][tid];
            let previousState = currentLocal; // Store for rollback

            // Logic
            if (currentLocal === -1) {
                currentLocal = 0; // Move to start
                sfx.move();
            } else {
                currentLocal += roll;
                sfx.move();
            }

            // Update State Tentatively
            gameState.tokens[pid][tid] = currentLocal;
            // renderTokens(); // Don't render yet if we might rollback? Actually we need to calculate global.
            // Let's render after verification.

            // Check Collision / Capture
            // Need Global Coordinates
            let collisionDetected = false;

            if (currentLocal < 52) { // Only on shared tracks
                const myGlobal = toGlobal(pid, currentLocal);
                // Check against others - STACK PROTECTION

                if (myGlobal !== -1) {
                    for (let op = 0; op < 4; op++) {
                        if (op === pid) continue;

                        // Count opponents on this cell
                        let stackedOpponents = 0;
                        gameState.tokens[op].forEach((opos) => {
                            if (opos !== -1 && opos < 52 && toGlobal(op, opos) === myGlobal) {
                                stackedOpponents++;
                            }
                        });

                        // If stack > 1, PROTECTED. Cannot land/kill.
                        if (stackedOpponents > 1) {
                            collisionDetected = true;
                            break;
                        }
                    }
                }
            }

            if (collisionDetected) {
                // Rollback
                gameState.tokens[pid][tid] = previousState;
                renderTokens();
                toast("ŸÖÿ≠ŸÖŸäÿ©! ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑŸÇÿ™ŸÑ üõ°Ô∏è");
                sfx.kill();
                isProcessingMove = false;
                nextTurn();
                return;
            }

            // Bonus throw for 6 or capture?
            // Standard Ludo: 6 gives another turn. 

            if (currentLocal >= 57) { // Reached Goal
                currentLocal = 57; // Cap
                checkWin(pid);
            }

            gameState.tokens[pid][tid] = currentLocal;
            renderTokens();

            // Next Turn decision
            if (roll === 6 || currentLocal === 57) { // Roll again if 6 OR Finished token (reward)
                if (currentLocal === 57 && !gameState.finished[pid]) {
                    toast("ŸàÿµŸÑÿ™! üèÅ ÿßŸÑÿπÿ® ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ");
                } else if (roll === 6) {
                    toast("ŸÑÿØŸäŸÉ ŸÑŸÅÿ© ÿ•ÿ∂ÿßŸÅŸäÿ©! üé≤");
                }

                if (gameState.finished[pid]) {
                    nextTurn(); // If finished completely, pass
                    return;
                }

                gameState.dice = 0;
                if (playMode === 'online') updateOnlineState(gameState);
                else {
                    updateUI();
                    if (playMode === 'offline' && gameState.turn !== 0) {
                        setTimeout(() => performRoll(), 1500);
                    }
                }
            } else {
                nextTurn();
            }
        }

        // nextTurn removed from here as it is redefined above in checkWin block context

        function toGlobal(pid, localPos) {
            // 56 Common Steps Logic
            if (localPos >= 56) return -1;
            const globalStartOffset = pid * 14; // 56 / 4 = 14 steps per quadrant
            return (globalStartOffset + localPos) % 56;
        }

        function isSafe(globalPos) {
            // New 56-track Safe Spots (Offsets: Start, +8)
            // Green: Start 0 (Global 0), +8 (Global 8)
            // Yellow: Start 0 (Global 14), +8 (Global 22)
            // Blue: Start 0 (Global 28), +8 (Global 36)
            // Red: Start 0 (Global 42), +8 (Global 50)
            const safes = [0, 8, 14, 22, 28, 36, 42, 50];
            return safes.includes(globalPos);
        }

        function checkWin(pid) {
            const allHome = gameState.tokens[pid].every(t => t >= 61);
            if (allHome && !gameState.finished[pid]) {
                gameState.finished[pid] = true;
                toast(`üèÜ ${gameState.players[pid].name} Wins!`);
                sfx.win();
                showConfetti(50);
            }
        }

        function nextTurn() {
            gameState.dice = 0;
            let checks = 0;
            do {
                gameState.turn = (gameState.turn + 1) % 4;
                checks++;
            } while (gameState.finished[gameState.turn] && checks < 4);

            if (playMode === 'online') {
                updateOnlineState(gameState);
            } else {
                updateUI();
                // Offline Logic
                if (gameState.turn !== 0 && !gameState.finished[gameState.turn]) {
                    setTimeout(() => performRoll(), 1000);
                }
            }
        }

        // --- IMPROVED RENDER TOKENS ---
        function renderTokens() {
            const layer = document.getElementById('tokens-layer');
            const ghostLayer = document.getElementById('ghost-layer');
            layer.innerHTML = "";
            ghostLayer.innerHTML = ""; // Clear ghosts

            // To handle stacking, we map coordinates to list of tokens
            const map = {};

            for (let p = 0; p < 4; p++) {
                gameState.tokens[p].forEach((pos, tId) => {
                    const xy = getCoordinates(p, pos, tId);
                    const key = xy.x + "," + xy.y;
                    if (!map[key]) map[key] = [];
                    map[key].push({ p, tId });
                });
            }

            // Draw
            for (let key in map) {
                const stack = map[key];
                stack.forEach((d, i) => {
                    const xy = key.split(',');
                    const el = document.createElement('div');
                    // Ensure color class matches index: 0=green, 1=yellow, 2=blue, 3=red
                    el.className = `token ${colors[d.p]}`;
                    el.id = `t-${d.p}-${d.tId}`;

                    // Stack Offset
                    const scale = stack.length > 1 ? 0.8 : 1;
                    const offX = stack.length > 1 ? (Math.random() * 20 - 10) : 0;
                    const offY = stack.length > 1 ? (Math.random() * 20 - 10) : 0;

                    el.style.left = (parseFloat(xy[0]) + offX) + 'px';
                    el.style.top = (parseFloat(xy[1]) + offY) + 'px';
                    el.style.transform = `translate(-50%, -50%) scale(${scale})`;
                    el.style.zIndex = 200 + i; // Ensure stacking order and clickability

                    // Interaction - ROBUST HANDLER
                    el.onclick = (e) => {
                        e.stopPropagation();
                        e.preventDefault();

                        // Debug info if needed
                        // console.log("Clicked", d.p, d.tId, gameState.turn, gameState.dice);

                        // 1. Basic Turn Check
                        if (playMode === 'online' && gameState.turn !== myColorIndex) return toast("ŸÑŸäÿ≥ ÿØŸàÿ±ŸÉ!");
                        if (playMode === 'offline' && gameState.turn !== 0 && d.p !== 0) return;

                        // 2. Dice Check
                        if (gameState.dice === 0 || isRolling) return toast("ÿßÿ±ŸÖŸê ÿßŸÑŸÜÿ±ÿØ ÿ£ŸàŸÑÿßŸã!");
                        if (d.p !== gameState.turn) return toast("Ÿáÿ∞Ÿá ŸÑŸäÿ≥ÿ™ ŸÇÿ∑ÿπÿ™ŸÉ!");

                        // 3. Move Logic
                        if (canMove(d.p, d.tId, gameState.dice)) {
                            // Valid Move
                            moveToken(d.p, d.tId);
                        } else {
                            const pos = gameState.tokens[d.p][d.tId];
                            if (pos === -1 && gameState.dice !== 6) toast("ÿ™ÿ≠ÿ™ÿßÿ¨ 6 ŸÑŸÑÿÆÿ±Ÿàÿ¨! üé≤");
                            else toast("ÿ≠ÿ±ŸÉÿ© ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ÿ©!");
                        }
                    };

                    // Cursor & Hover
                    const myTurn = (playMode === 'online' ? gameState.turn === myColorIndex : gameState.turn === 0);
                    // Simplify validation for UI to ensure it matches click logic
                    const canM = (myTurn && !isRolling && gameState.dice > 0 && d.p === gameState.turn && canMove(d.p, d.tId, gameState.dice));

                    if (canM) {
                        el.style.cursor = "pointer";
                        el.classList.add('glow');
                        // High Z-index for active tokens
                        el.style.zIndex = 999;

                        el.onmouseenter = () => showGhost(d.p, gameState.tokens[d.p][d.tId], gameState.dice);
                        el.onmouseleave = () => ghostLayer.innerHTML = "";
                    } else {
                        el.style.cursor = "default";
                        el.style.zIndex = 200 + i; // Standard stack z
                    }

                    layer.appendChild(el);
                });
            }
        }

        function showGhost(pid, currentPos, roll) {
            if (roll === 0) return;
            // Calculate next pos
            let nextPos = (currentPos === -1) ? 0 : currentPos + roll;
            if (nextPos > 57) return;

            const xy = getCoordinates(pid, nextPos, 0); // tId 0 is fine for ghost loc
            const g = document.createElement('div');
            g.className = 'ghost-token';
            g.style.left = xy.x + 'px';
            g.style.top = xy.y + 'px';
            document.getElementById('ghost-layer').appendChild(g);
        }

        function getCoordinates(pid, pos, tokenIndex) {
            // Correct Base Coordinates with Separation
            // We spread tokens in base so they don't overlap perfectly
            // Green(0): Top-Left. Bases at ~150-350 range.
            const bases = [
                // Green Base (Spread positions)
                [[180, 180], [320, 180], [180, 320], [320, 320]],
                // Yellow Base (Spread positions)
                [[1080, 180], [1220, 180], [1080, 320], [1220, 320]],
                // Blue Base (Spread positions)
                [[1080, 1080], [1220, 1080], [1080, 1220], [1220, 1220]],
                // Red Base (Spread positions)
                [[180, 1080], [320, 1080], [180, 1220], [320, 1220]]
            ];

            if (pos === -1) {
                const b = bases[pid][tokenIndex]; // Use tokenIndex to pick specific slot!

                const wrapper = document.getElementById('game-container').offsetWidth;
                const px = (b[0] / 1500) * 100; // %
                const py = (b[1] / 1500) * 100; // %

                return { x: px * (wrapper / 100), y: py * (wrapper / 100) };
            }

            if (pos >= 57) { // Goal Center - Visual Offset per Player
                const wrapper = document.getElementById('game-container').offsetWidth;
                // Offset into their color triangle
                // Green (0): Left-Top -> Center is (7,7). Triangle points Left? No, Green is Left.
                // Bases: G(TL), Y(TR), B(BR), R(BL).
                // Home Triangles: G(Left), Y(Top), B(Right), R(Bottom).
                const center = wrapper / 2;
                const offset = wrapper * 0.05;

                // Specific manual offsets for visual clarity
                if (pid === 0) return { x: center - offset, y: center - offset }; // Green TL-ish
                if (pid === 1) return { x: center + offset, y: center - offset }; // Yellow TR-ish
                if (pid === 2) return { x: center + offset, y: center + offset }; // Blue BR-ish
                if (pid === 3) return { x: center - offset, y: center + offset }; // Red BL-ish
                return { x: center, y: center };
            }

            // Path Logic
            const track = getPathForPlayer(pid);
            if (pos < track.length) {
                const pt = track[pos];
                // Grid 0-14. 
                // X = (pt[0] * 100 + 50)
                const sx = (pt[0] * 100 + 50);
                const sy = (pt[1] * 100 + 50);

                const wrapper = document.getElementById('game-container').offsetWidth;
                return { x: (sx / 1500) * wrapper, y: (sy / 1500) * wrapper };
            }
            return { x: 0, y: 0 };
        }

        function getPathForPlayer(pid) {
            // Base path (Green)
            // 0=(1,6), 1=(2,6), 2=(3,6), 3=(4,6), 4=(5,6)
            // 5=(6,5), 6=(6,4), 7=(6,3), 8=(6,2), 9=(6,1), 10=(6,0)
            // 11=(7,0), 12=(8,0) (Top pivot)
            // 13=(8,1), 14=(8,2)... down

            // We generate 57 points for Green. Then rotate for others.
            const p = [];
            // 0-4
            for (let i = 1; i <= 5; i++) p.push([i, 6]);
            // 5-10
            for (let i = 5; i >= 0; i--) p.push([6, i]);
            // 11-12
            p.push([7, 0], [8, 0]);
            // 13-18
            for (let i = 1; i <= 6; i++) p.push([8, i]);
            // 19-23
            for (let i = 9; i <= 13; i++) p.push([i, 6]);
            // 24-25
            p.push([14, 6], [14, 7]); // Right Pivot
            // 26-30
            for (let i = 13; i >= 9; i--) p.push([i, 8]);
            // 31-36
            for (let i = 9; i <= 14; i++) p.push([8, i]);
            // 37-38
            p.push([8, 14], [7, 14]); // Bottom Pivot
            // 39-44
            for (let i = 14; i >= 9; i--) p.push([6, i]);
            // 45-49
            for (let i = 5; i >= 1; i--) p.push([i, 8]);
            // 50-51 (Up to finish entry)
            p.push([0, 8], [0, 7]); // Left Pivot

            // 52-56 (Home Run Green) -> (1,7) to (5,7)
            for (let i = 1; i <= 5; i++) p.push([i, 7]);
            // 57 Goal
            p.push([7, 7]);

            // Rotate points for PID
            // 0: No rot. 1: 90deg CW. 2: 180. 3: 270.
            // Rotate (x,y) around (7,7)
            // x' = (x-7)cos - (y-7)sin + 7
            // y' = (x-7)sin + (y-7)cos + 7

            const angle = (Math.PI / 2) * pid;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);

            return p.map(pt => {
                const x = pt[0] - 7;
                const y = pt[1] - 7;
                const rx = Math.round(x * cos - y * sin + 7);
                const ry = Math.round(x * sin + y * cos + 7);
                return [rx, ry];
            });
        }

        // --- CHAT & UTILS ---
        function toast(msg) {
            const t = document.getElementById('toast');
            document.getElementById('toast-msg').innerText = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 3000);
        }

        function copyCode() {
            navigator.clipboard.writeText(currentRoom);
            toast("ÿ™ŸÖ ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ! üìã");
        }

        function showConfetti() {
            for (let i = 0; i < 30; i++) {
                const c = document.createElement('div');
                c.className = 'confetti';
                c.style.left = Math.random() * 100 + 'vw';
                c.style.backgroundColor = ['red', 'yellow', 'green', 'blue'][Math.floor(Math.random() * 4)];
                c.style.animationDuration = (Math.random() * 2 + 2) + 's';
                document.body.appendChild(c);
                setTimeout(() => c.remove(), 4000);
            }
        }

        // Chat
        function toggleChat() {
            const b = document.getElementById('chat-box');
            b.classList.toggle('open');
            if (b.classList.contains('open')) b.classList.remove('hidden');
        }

        function sendChat() {
            const inp = document.getElementById('chat-input');
            const txt = inp.value.trim();
            if (!txt) return;
            // Send
            if (playMode === 'online') db.ref('ludo_rooms/' + currentRoom + '/chat').push({ n: myName, m: txt });
            else { // Local Echo
                addMsg(myName, txt);
            }
            inp.value = "";
        }

        function addMsg(n, m) {
            const d = document.getElementById('chat-msgs');
            d.innerHTML += `<div class="msg"><b>${n}:</b> ${m}</div>`;
            d.scrollTop = d.scrollHeight;
        }

        // Online Listeners extras
        // Note: Full sync logic handles most. Chat needs separate listener if online.

    </script>
</body>

</html>
