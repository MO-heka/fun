<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HEKA LUDaO MASTER</title>

    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

    <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #0f172a;
            --glass-bg: rgba(30, 41, 59, 0.85);
            --glass-border: rgba(255, 255, 255, 0.1);
            --green: #22c55e;
            --yellow: #eab308;
            --blue: #3b82f6;
            --red: #ef4444;
            --accent: #f59e0b;
            --shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            --font-main: 'Cairo', sans-serif;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-color);
            color: white;
            font-family: var(--font-main);
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-image: radial-gradient(circle at 50% 50%, #1e293b 0%, #0f172a 100%);
            overflow: hidden;
            /* Prevent scroll */
        }

        /* Wood Texture for Board */
        .wood-texture {
            background-color: #d4a373;
            background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h20v20H0V0zm10 17a7 7 0 1 0 0-14 7 7 0 0 0 0 14zm20 0a7 7 0 1 0 0-14 7 7 0 0 0 0 14zM10 37a7 7 0 1 0 0-14 7 7 0 0 0 0 14zm10-17h20v20H20V20zm10 17a7 7 0 1 0 0-14 7 7 0 0 0 0 14z' fill='%23faedcd' fill-opacity='0.1' fill-rule='evenodd'/%3E%3C/svg%3E");
        }

        /* Screen Management */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s;
            z-index: 10;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            z-index: -1;
            display: none !important;
        }

        /* UI Components */
        .panel {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            padding: 25px;
            border-radius: 20px;
            text-align: center;
            box-shadow: var(--shadow);
            backdrop-filter: blur(10px);
            width: 90%;
            max-width: 400px;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        h1 {
            margin: 0 0 20px;
            color: var(--accent);
            font-weight: 900;
            text-shadow: 0 0 15px rgba(245, 158, 11, 0.3);
        }

        button {
            background: linear-gradient(135deg, #6366f1, #4f46e5);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 1.1rem;
            font-family: var(--font-main);
            font-weight: bold;
            margin: 10px;
            cursor: pointer;
            width: 100%;
            transition: transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px 0 #3730a3;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: none;
        }

        button.secondary {
            background: #334155;
            box-shadow: 0 4px 0 #1e293b;
        }

        input {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border: 2px solid #334155;
            background: rgba(0, 0, 0, 0.2);
            color: white;
            font-family: var(--font-main);
            text-align: center;
            font-size: 1.2rem;
            outline: none;
        }

        input:focus {
            border-color: var(--accent);
        }

        input:focus {
            border-color: var(--accent);
        }

        .safe-spot-marker {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            opacity: 0.5;
            pointer-events: none;
        }

        /* Hit Area Boost */
        .token::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            border-radius: 50%;
            z-index: -1;
        }

        /* Game Area */
        #game-container {
            position: relative;
            width: 100vw;
            max-width: 600px;
            aspect-ratio: 1/1;
            margin: auto;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
        }

        /* SVG Board */
        #ludo-board {
            width: 100%;
            height: 100%;
            background: #fff;
            border-radius: 5px;
        }

        /* Tokens */
        .token {
            position: absolute;
            width: 6%;
            height: 6%;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 4px 5px rgba(0, 0, 0, 0.4), inset 0 -3px 5px rgba(0, 0, 0, 0.3), inset 0 3px 5px rgba(255, 255, 255, 0.4);
            transform: translate(-50%, -50%);
            transition: top 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), left 0.4s cubic-bezier(0.34, 1.56, 0.64, 1), transform 0.1s;
            cursor: pointer;
            z-index: 100;
            /* 3D look */
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.8), transparent 20%),
                conic-gradient(from 180deg, rgba(0, 0, 0, 0.2), transparent 50%);
        }

        .token::after {
            content: '';
            position: absolute;
            top: 20%;
            left: 20%;
            right: 20%;
            bottom: 20%;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.1);
            filter: blur(2px);
        }

        .token.green {
            background-color: #00b960;
            border-color: #008f4c;
        }

        .token.yellow {
            background-color: #f1c40f;
            border-color: #d4ac0d;
        }

        .token.blue {
            background-color: #2980b9;
            border-color: #1f618d;
        }

        .token.red {
            background-color: #c0392b;
            border-color: #922b21;
        }

        /* Ghost Token for Hover */
        .ghost-token {
            position: absolute;
            width: 6%;
            height: 6%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            border: 2px dashed white;
            z-index: 90;
            opacity: 0.6;
            pointer-events: none;
            transform: translate(-50%, -50%);
            animation: pulse-ghost 1s infinite;
        }

        @keyframes pulse-ghost {
            50% {
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 0.8;
            }
        }

        .token.yellow {
            background: var(--yellow);
        }

        .token.blue {
            background: var(--blue);
        }

        .token.red {
            background: var(--red);
        }

        .token.glow {
            animation: pulse-glow 1s infinite alternate;
            z-index: 110;
            cursor: pointer;
        }

        .token.stacked-2 {
            transform: translate(-50%, -60%) scale(0.9);
        }

        /* Dice */
        #dice-panel {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 80px;
            background: rgba(255, 255, 255, 0.95);
            /* Force visible bg */
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 3px solid #334155;
            /* Distinct border */
            cursor: pointer;
            transition: transform 0.1s;
            z-index: 2000;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #dice-panel.disabled {
            filter: grayscale(1);
            cursor: not-allowed;
            opacity: 0.8;
            /* Kept visible but dimmed so others see the roll */
        }

        #dice-panel:active {
            transform: scale(0.95);
        }

        #dice-cube {
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 10px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 6px;
            gap: 2px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .dot {
            background: #333;
            border-radius: 50%;
            opacity: 0;
        }

        /* Dice Dot Configurations (0=hidden, 1=visible) */
        .d-1> :nth-child(5) {
            opacity: 1;
        }

        .d-2> :nth-child(1),
        .d-2> :nth-child(9) {
            opacity: 1;
        }

        .d-3> :nth-child(1),
        .d-3> :nth-child(5),
        .d-3> :nth-child(9) {
            opacity: 1;
        }

        .d-4> :nth-child(1),
        .d-4> :nth-child(3),
        .d-4> :nth-child(7),
        .d-4> :nth-child(9) {
            opacity: 1;
        }

        .d-5> :nth-child(1),
        .d-5> :nth-child(3),
        .d-5> :nth-child(5),
        .d-5> :nth-child(7),
        .d-5> :nth-child(9) {
            opacity: 1;
        }

        .d-6> :nth-child(1),
        .d-6> :nth-child(3),
        .d-6> :nth-child(4),
        .d-6> :nth-child(6),
        .d-6> :nth-child(7),
        .d-6> :nth-child(9) {
            opacity: 1;
        }

        .rolling {
            animation: shake 0.4s infinite;
        }

        /* Player Info */
        .player-card {
            position: absolute;
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 30px;
            display: flex;
            align-items: center;
            gap: 10px;
            border: 2px solid transparent;
            transition: 0.3s;
            font-size: 0.9rem;
        }

        .player-card img {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #333;
        }

        .player-card.active {
            border-color: var(--accent);
            background: rgba(245, 158, 11, 0.2);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.3);
        }

        .p-green {
            top: 10px;
            left: 10px;
        }

        .p-yellow {
            top: 10px;
            right: 10px;
        }

        .p-red {
            bottom: 10px;
            left: 10px;
        }

        /* Swapped standard positions for UI balance */
        .p-blue {
            bottom: 10px;
            right: 10px;
        }

        /* Notification Toast */
        #toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid var(--accent);
            z-index: 1000;
            transition: 0.3s;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #toast.show {
            transform: translateX(-50%) translateY(0);
        }

        /* Chat */
        #chat-btn {
            position: fixed;
            bottom: 120px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--blue);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 200;
            border: none;
        }

        #chat-box {
            position: fixed;
            bottom: 180px;
            right: 20px;
            width: 300px;
            height: 350px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            z-index: 201;
            transform: scale(0);
            transition: 0.2s;
            transform-origin: bottom right;
        }

        #chat-box.open {
            transform: scale(1);
        }

        .msg {
            padding: 5px 10px;
            margin: 5px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            font-size: 0.85rem;
        }

        /* Animations */
        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes pulse-glow {
            from {
                box-shadow: 0 0 5px white;
            }

            to {
                box-shadow: 0 0 20px var(--accent);
            }
        }

        @keyframes shake {
            0% {
                transform: rotate(0deg);
            }

            25% {
                transform: rotate(10deg);
            }

            50% {
                transform: rotate(0deg);
            }

            75% {
                transform: rotate(-10deg);
            }

            100% {
                transform: rotate(0deg);
            }
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: red;
            animation: fall 3s linear forwards;
        }

        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(720deg);
            }
        }


        /* Mobile Optimization */
        @media (max-width: 600px) {
            #game-container {
                width: 96vw;
                height: 96vw;
                /* Keep square */
                margin-top: 60px;
                /* Space for top players */
            }

            .player-card {
                padding: 4px 8px;
                background: rgba(0, 0, 0, 0.8);
                font-size: 0.75rem;
            }

            .player-card img {
                width: 25px;
                height: 25px;
            }

            /* Custom Positioning for Mobile to not cover board */
            #dice-panel {
                bottom: 20px;
                left: 50%;
                transform: translateX(-50%);
                width: 70px;
                height: 70px;
            }

            #dice-panel:active {
                transform: translateX(-50%) scale(0.95);
            }

            #chat-btn {
                bottom: 20px;
                left: 20px;
                right: auto;
                width: 45px;
                height: 45px;
                font-size: 20px;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            }

            #chat-box {
                bottom: 80px;
                left: 20px;
                right: auto;
                width: 80vw;
                height: 40vh;
                transform-origin: bottom left;
            }

            h1 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>

<body>

    <!-- Notification -->
    <div id="toast">üîî <span id="toast-msg"></span></div>

    <!-- MAIN MENU -->
    <div id="screen-menu" class="screen">
        <div class="panel">
            <h1>üé≤ LUDO MASTER</h1>
            <h3 id="welcome-msg" style="color: #cbd5e1; margin-bottom: 20px;"></h3>
            <button onclick="startGame('offline')">üë§ ÿ∂ÿØ ÿßŸÑŸÉŸÖÿ®ŸäŸàÿ™ÿ± (Offline)</button>
            <button onclick="showOnlineMenu()" style="background: linear-gradient(135deg, #f59e0b, #d97706);">üåê ŸÑÿπÿ®
                ÿ£ŸàŸÜŸÑÿßŸäŸÜ (Online)</button>
        </div>
    </div>

    <!-- ONLINE MENU -->
    <div id="screen-online" class="screen hidden">
        <div class="panel">
            <h2>üåç ÿßŸÑÿ£ŸàŸÜŸÑÿßŸäŸÜ</h2>

            <div style="margin-bottom: 15px;">
                <label style="display:block; margin-bottom:5px; color:#cbd5e1">ÿßÿÆÿ™ÿ± ÿ¥ŸÉŸÑŸÉ:</label>
                <div style="display:flex; justify-content:center; gap:10px;">
                    <div onclick="selectAvatar('Felix')" class="avatar-opt"
                        style="cursor:pointer; border:2px solid transparent; border-radius:50%; padding:2px;"><img
                            src="https://api.dicebear.com/7.x/avataaars/svg?seed=Felix" width="40"></div>
                    <div onclick="selectAvatar('Aneka')" class="avatar-opt"
                        style="cursor:pointer; border:2px solid transparent; border-radius:50%; padding:2px;"><img
                            src="https://api.dicebear.com/7.x/avataaars/svg?seed=Aneka" width="40"></div>
                    <div onclick="selectAvatar('Bob')" class="avatar-opt"
                        style="cursor:pointer; border:2px solid transparent; border-radius:50%; padding:2px;"><img
                            src="https://api.dicebear.com/7.x/avataaars/svg?seed=Bob" width="40"></div>
                    <div onclick="selectAvatar('Zack')" class="avatar-opt"
                        style="cursor:pointer; border:2px solid transparent; border-radius:50%; padding:2px;"><img
                            src="https://api.dicebear.com/7.x/avataaars/svg?seed=Zack" width="40"></div>
                    <div onclick="selectAvatar('Bear')" class="avatar-opt"
                        style="cursor:pointer; border:2px solid transparent; border-radius:50%; padding:2px;"><img
                            src="https://api.dicebear.com/7.x/avataaars/svg?seed=Bear" width="40"></div>
                </div>
            </div>

            <button onclick="createRoom()">‚ûï ÿ•ŸÜÿ¥ÿßÿ° ÿ∫ÿ±ŸÅÿ©</button>
            <div style="display:flex; gap: 5px; align-items: center;">
                <input id="room-code-input" placeholder="ÿßŸÉÿ™ÿ® ŸÉŸàÿØ ÿßŸÑÿ∫ÿ±ŸÅÿ©" style="margin: 0;">
                <button onclick="joinRoom()" style="width: auto; padding: 15px;">ÿØÿÆŸàŸÑ</button>
            </div>
            <button class="secondary" onclick="showScreen('screen-menu')">ÿ±ÿ¨Ÿàÿπ</button>
        </div>
    </div>

    <!-- LOBBY -->
    <div id="screen-lobby" class="screen hidden">
        <div class="panel">
            <h2>üõãÔ∏è ÿµÿßŸÑÿ© ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±</h2>
            <div style="background: rgba(0,0,0,0.3); padding: 10px; border-radius: 10px; margin: 10px 0;">
                <span style="color: #94a3b8; font-size: 0.9rem;">ŸÉŸàÿØ ÿßŸÑÿ∫ÿ±ŸÅÿ©:</span>
                <div style="font-size: 2rem; color: var(--accent); letter-spacing: 2px; font-weight: bold; cursor: pointer;"
                    onclick="copyCode()" id="lobby-code">---</div>
                <div style="font-size: 0.8rem; color: #64748b;">(ÿßÿ∂ÿ∫ÿ∑ ŸÑŸÑŸÜÿ≥ÿÆ)</div>
            </div>
            <div id="lobby-players" style="text-align: right; min-height: 100px;">
                <!-- Player List -->
            </div>
            <button id="start-btn" class="hidden" onclick="startOnlineGame()">üöÄ ÿßÿ®ÿØÿ£ ÿßŸÑŸÑÿπÿ®</button>
            <button class="secondary" onclick="leaveRoom()">ÿÆÿ±Ÿàÿ¨</button>
        </div>
    </div>

    <!-- GAME AREA -->
    <div id="screen-game" class="screen hidden">
        <!-- Player Stats (Mobile Optimized) -->
        <div class="player-card" id="p-card-0" style="top:5px; left:5px;">
            <img src="https://api.dicebear.com/7.x/avataaars/svg?seed= Felix">
            <div class="p-info"><span class="p-name">Player 1</span></div>
        </div>
        <div class="player-card" id="p-card-1" style="top:5px; right:5px; flex-direction: row-reverse;">
            <img src="https://api.dicebear.com/7.x/avataaars/svg?seed=Aneka">
            <div class="p-info"><span class="p-name">Player 2</span></div>
        </div>
        <div class="player-card" id="p-card-2" style="bottom:100px; right:5px; flex-direction: row-reverse;">
            <div class="p-info"><span class="p-name">Player 3</span></div> <img
                src="https://api.dicebear.com/7.x/avataaars/svg?seed=Bob">
        </div>
        <div class="player-card" id="p-card-3" style="bottom:100px; left:5px;">
            <img src="https://api.dicebear.com/7.x/avataaars/svg?seed=Zack">
            <div class="p-info"><span class="p-name">Player 4</span></div>
        </div>

        <!-- The Board -->
        <div id="game-container">
            <svg id="ludo-board" viewBox="0 0 1500 1500">
                <!-- Defs -->
                <defs>
                    <!-- Gradients for Bases -->
                    <radialGradient id="greenGrad" cx="50%" cy="50%">
                        <stop offset="0%" style="stop-color:#4ade80;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#16a34a;stop-opacity:1" />
                    </radialGradient>
                    <radialGradient id="yellowGrad" cx="50%" cy="50%">
                        <stop offset="0%" style="stop-color:#fde047;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#ca8a04;stop-opacity:1" />
                    </radialGradient>
                    <radialGradient id="blueGrad" cx="50%" cy="50%">
                        <stop offset="0%" style="stop-color:#60a5fa;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#1e40af;stop-opacity:1" />
                    </radialGradient>
                    <radialGradient id="redGrad" cx="50%" cy="50%">
                        <stop offset="0%" style="stop-color:#f87171;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#b91c1c;stop-opacity:1" />
                    </radialGradient>

                    <!-- 3D Shadow Filter -->
                    <filter id="shadow3d" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur in="SourceAlpha" stdDeviation="3" />
                        <feOffset dx="2" dy="2" result="offsetblur" />
                        <feComponentTransfer>
                            <feFuncA type="linear" slope="0.5" />
                        </feComponentTransfer>
                        <feMerge>
                            <feMergeNode />
                            <feMergeNode in="SourceGraphic" />
                        </feMerge>
                    </filter>

                    <!-- Star pattern for safe spots -->
                    <polygon id="star-shape" points="50,15 61,45 90,45 68,62 76,90 50,73 24,90 32,62 10,45 39,45"
                        fill="currentColor" filter="url(#shadow3d)" />
                </defs>

                <!-- Background -->
                <rect width="1500" height="1500" fill="#f8f9fa" rx="20" />

                <!-- Wood Frame with 3D effect -->
                <rect x="0" y="0" width="1500" height="1500" rx="20" fill="none" stroke="url(#woodGrad)"
                    stroke-width="30" filter="url(#shadow3d)" />

                <!-- Bases with Gradients -->
                <rect x="0" y="0" width="600" height="600" fill="url(#greenGrad)" filter="url(#shadow3d)" />
                <rect x="900" y="0" width="600" height="600" fill="url(#yellowGrad)" filter="url(#shadow3d)" />
                <rect x="900" y="900" width="600" height="600" fill="url(#blueGrad)" filter="url(#shadow3d)" />
                <rect x="0" y="900" width="600" height="600" fill="url(#redGrad)" filter="url(#shadow3d)" />

                <!-- Inner Whites -->
                <rect x="100" y="100" width="400" height="400" fill="white" rx="40" filter="url(#shadow3d)" />
                <rect x="1000" y="100" width="400" height="400" fill="white" rx="40" filter="url(#shadow3d)" />
                <rect x="1000" y="1000" width="400" height="400" fill="white" rx="40" filter="url(#shadow3d)" />
                <rect x="100" y="1000" width="400" height="400" fill="white" rx="40" filter="url(#shadow3d)" />

                <!-- Enhanced Center with Glow -->
                <circle cx="750" cy="750" r="120" fill="#fbbf24" opacity="0.3" filter="url(#shadow3d)" />
                <polygon points="600,600 900,600 750,750" fill="#eab308" opacity="0.9" filter="url(#shadow3d)" />
                <polygon points="900,600 900,900 750,750" fill="#3b82f6" opacity="0.9" filter="url(#shadow3d)" />
                <polygon points="900,900 600,900 750,750" fill="#ef4444" opacity="0.9" filter="url(#shadow3d)" />
                <polygon points="600,900 600,600 750,750" fill="#22c55e" opacity="0.9" filter="url(#shadow3d)" />
                <circle cx="750" cy="750" r="80" fill="#fef3c7" stroke="#f59e0b" stroke-width="5" />
                <text x="750" y="765" text-anchor="middle" font-size="40" font-weight="bold" fill="#92400e">üèÜ</text>

                <!-- Tracks -->
                <g id="grid-lines" stroke="#ccc" stroke-width="2">
                    <!-- ... existing lines ... -->
                    <line x1="600" y1="0" x2="600" y2="1500" />
                    <line x1="700" y1="0" x2="700" y2="600" />
                    <line x1="800" y1="0" x2="800" y2="600" />
                    <line x1="700" y1="900" x2="700" y2="1500" />
                    <line x1="800" y1="900" x2="800" y2="1500" />
                    <line x1="900" y1="0" x2="900" y2="1500" />
                    <line x1="0" y1="600" x2="1500" y2="600" />
                    <line x1="0" y1="700" x2="600" y2="700" />
                    <line x1="0" y1="800" x2="600" y2="800" />
                    <line x1="900" y1="700" x2="1500" y2="700" />
                    <line x1="900" y1="800" x2="1500" y2="800" />
                    <line x1="0" y1="900" x2="1500" y2="900" />
                    <path d="M600 100 H900 M600 200 H900 M600 300 H900 M600 400 H900 M600 500 H900" />
                    <path d="M600 1000 H900 M600 1100 H900 M600 1200 H900 M600 1300 H900 M600 1400 H900" />
                    <path d="M100 600 V900 M200 600 V900 M300 600 V900 M400 600 V900 M500 600 V900" />
                    <path d="M1000 600 V900 M1100 600 V900 M1200 600 V900 M1300 600 V900 M1400 600 V900" />
                </g>

                <!-- Home Runs Colors Corrected -->
                <!-- Top: Yellow -->
                <rect x="700" y="100" width="100" height="500" fill="#eab308" opacity="0.4" />
                <!-- Right: Blue -->
                <rect x="900" y="700" width="500" height="100" fill="#3b82f6" opacity="0.4" />
                <!-- Bottom: Red -->
                <rect x="700" y="900" width="100" height="500" fill="#ef4444" opacity="0.4" />
                <!-- Left: Green -->
                <rect x="100" y="700" width="500" height="100" fill="#22c55e" opacity="0.4" />

                <!-- Safe Spots (Darkened Cells) -->
                <defs>
                    <g id="safe-cell">
                        <rect x="0" y="0" width="100" height="100" fill="#0f172a" opacity="0.8" />
                        <text x="50" y="70" font-size="50" text-anchor="middle" fill="#64748b">üõ°Ô∏è</text>
                    </g>
                </defs>

                <!-- Base Safe Exits (Colored Start Squares) -->
                <!-- Green Start (Left): x100 y600 -->
                <rect x="100" y="600" width="100" height="100" fill="#22c55e" opacity="0.5" />
                <!-- Yellow Start (Top): x800 y100 -->
                <rect x="800" y="100" width="100" height="100" fill="#eab308" opacity="0.5" />
                <!-- Blue Start (Right): x1300 y800 -->
                <rect x="1300" y="800" width="100" height="100" fill="#3b82f6" opacity="0.5" />
                <!-- Red Start (Bottom): x600 y1300 -->
                <rect x="600" y="1300" width="100" height="100" fill="#ef4444" opacity="0.5" />

                <!-- Safe Spots (Shields) -->
                <!-- Safe spot cells with shield emoji -->
                <g id="safe-spot">
                    <rect width="100" height="100" fill="#0f172a" opacity="0.4" />
                    <text x="50" y="60" font-size="40" text-anchor="middle" dominant-baseline="middle"
                        fill="#64748b">üõ°Ô∏è</text>
                </g>

                <!-- Star Positions (Safe) -->
                <use href="#safe-spot" x="600" y="200" />
                <use href="#safe-spot" x="1200" y="600" />
                <use href="#safe-spot" x="800" y="1200" />
                <use href="#safe-spot" x="200" y="800" />

                <!-- Start Positions (Safe) -->
                <use href="#safe-spot" x="100" y="600" />
                <use href="#safe-spot" x="800" y="100" />
                <use href="#safe-spot" x="1300" y="800" />
                <use href="#safe-spot" x="600" y="1300" />
            </svg>

            <!-- Tokens & Ghosts -->
            <div id="ghost-layer"></div>
            <div id="tokens-layer"></div>

            <!-- Turn Indicator Overlay on Center -->
            <div id="turn-indicator" style="position: absolute; top:50%; left:50%; transform:translate(-50%,-50%); 
                 width:100px; height:100px; pointer-events:none; border-radius:50%; 
                 border: 5px solid transparent; transition:border-color 0.3s; z-index:50;"></div>
        </div>

        <!-- Controls -->
        <!-- Dice is now always visible but disabled when not your turn -->
        <div id="dice-panel" class="" onclick="requestRoll()">
            <div id="dice-cube" class="d-6">
                <!-- 3D Transform faces would be better, but flat for now with polish -->
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
                <div class="dot"></div>
            </div>
            <div id="dice-msg"
                style="position: absolute; bottom: -30px; font-weight: bold; font-size: 0.8rem; width: 120px; text-align: center; color:var(--accent); text-shadow:0 1px 2px black;">
                ÿßÿ∂ÿ∫ÿ∑ ŸÑŸÑÿ±ŸÖŸä
            </div>
        </div>

        <button id="chat-btn" onclick="toggleChat()">üí¨</button>
        <div id="chat-box" class="hidden">
            <div
                style="padding: 10px; background: var(--accent); color: black; font-weight: bold; border-radius: 12px 12px 0 0; display:flex; justify-content:space-between;">
                <span>ÿ¥ÿßÿ™ ÿßŸÑÿ∫ÿ±ŸÅÿ©</span> <span onclick="toggleChat()">‚úñ</span>
            </div>
            <div id="chat-msgs" style="flex: 1; overflow-y: auto; padding: 10px;"></div>
            <div style="display: flex; padding: 5px;">
                <input id="chat-input" placeholder="ÿßŸÉÿ™ÿ®..." style="margin: 0; flex:1">
                <button onclick="sendChat()" style="width: auto; padding: 0 15px; margin: 0 5px;">‚û§</button>
            </div>
        </div>

        <!-- Particles Container -->
        <div id="particles-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
             pointer-events: none; z-index: 9999;"></div>
    </div>

    <script>
        // --- CONFIG & UTILS ---
        // --- CONFIG & UTILS ---
        const colors = ['green', 'yellow', 'blue', 'red'];

        // Firebase Configuration (Required for Online/Offline DB calls if any)
        const firebaseConfig = {
            apiKey: "AIzaSyCp9_P3K__Sr76iKgaVG1iD4NluUqPtni4",
            authDomain: "heka-codenames.firebaseapp.com",
            projectId: "heka-codenames",
            storageBucket: "heka-codenames.firebasestorage.app",
            messagingSenderId: "901713932504",
            appId: "1:901713932504:web:7079662022a501e9c4e7ad",
            databaseURL: "https://heka-codenames-default-rtdb.firebaseio.com"
        };
        if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        let gameState = {
            turn: 0,
            dice: 0,
            tokens: [[-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]], // 0:green, 1:yellow, 2:blue, 3:red
            lastMove: null,
            finished: [false, false, false, false],
            players: [],
            consecutive6s: 0,        // Track consecutive 6s
            rollsWithout6: [0, 0, 0, 0]  // Track rolls without 6 for each player
        };

        let myName = localStorage.getItem('heka_global_player_name') || "Player";
        let myId = Math.random().toString(36).substr(2, 9);
        let myAvatar = 'Felix';
        let currentRoom = null;
        let playMode = 'offline'; // offline, online
        let myColorIndex = 0; // if online
        let diceAnimInterval;
        let isRolling = false;
        let isProcessingMove = false;

        // --- SOUNDS ---
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        const ctx = new AudioCtx();
        function playTone(freq, type = 'sine', dur = 0.1) {
            if (ctx.state === 'suspended') ctx.resume();
            const o = ctx.createOscillator(); const g = ctx.createGain();
            o.type = type; o.frequency.value = freq;
            o.connect(g); g.connect(ctx.destination);
            o.start(); g.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + dur);
            o.stop(ctx.currentTime + dur);
        }
        const sfx = {
            move: () => playTone(300, 'triangle', 0.1),
            dice: () => playTone(400, 'square', 0.05),
            kill: () => { playTone(150, 'sawtooth', 0.2); setTimeout(() => playTone(100, 'sawtooth', 0.4), 100); },
            win: () => { playTone(500, 'sine', 0.2); setTimeout(() => playTone(800, 'square', 0.4), 200); }
        };

        // --- INIT ---
        window.onload = () => {
            document.getElementById('welcome-msg').innerText = "ŸÖÿ±ÿ≠ÿ®ÿßŸã " + myName;
            renderTokens();
        };

        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById(id).classList.remove('hidden');
        }

        // --- NAVIGATION ---
        function startGame(mode) {
            playMode = mode;
            if (mode === 'offline') {
                myColorIndex = 0;
                gameState.players = [
                    { name: myName, id: 'me', avatar: myAvatar },
                    { name: 'Bot 1', id: 'bot', avatar: 'Felix' },
                    { name: 'Bot 2', id: 'bot', avatar: 'Bear' },
                    { name: 'Bot 3', id: 'bot', avatar: 'Zack' }
                ];
                gameState.turn = 0;
                resetBoard();
                showScreen('screen-game');

                // Hide chat in offline mode
                document.getElementById('chat-btn').style.display = 'none';
                document.getElementById('chat-box').classList.add('hidden');

                updateUI();
                // initEnhancements(); // Disabled per user request
            }
        }

        function showOnlineMenu() { showScreen('screen-online'); }

        // --- ONLINE LOGIC ---
        function createRoom() {
            const code = Math.floor(1000 + Math.random() * 9000).toString();
            db.ref('ludo_rooms/' + code).set({
                players: [{ name: myName, id: myId, color: 0, avatar: myAvatar }],
                turn: 0,
                dice: 0,
                tokens: gameState.tokens,
                status: 'waiting'
            });
            enterLobby(code, 0);
        }

        function joinRoom() {
            const code = document.getElementById('room-code-input').value;
            db.ref('ludo_rooms/' + code).once('value', s => {
                if (!s.exists()) return toast('ÿßŸÑÿ∫ÿ±ŸÅÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©');
                const d = s.val();
                if (d.status !== 'waiting') return toast('ÿßŸÑŸÑÿπÿ®ÿ© ÿ®ÿØÿ£ÿ™ ÿ®ÿßŸÑŸÅÿπŸÑ');
                if (d.players.length >= 4) return toast('ÿßŸÑÿ∫ÿ±ŸÅÿ© ŸÖŸÖÿ™ŸÑÿ¶ÿ©');

                const color = d.players.length;
                d.players.push({ name: myName, id: myId, color: color, avatar: myAvatar });
                db.ref('ludo_rooms/' + code).update({ players: d.players });
                enterLobby(code, color);
            });
        }

        // --- CHAT LOGIC ---
        function toggleChat() {
            const box = document.getElementById('chat-box');
            box.classList.toggle('hidden');
            box.classList.toggle('open');
            // Clear unread indicator if any needed
        }

        function sendChat() {
            const input = document.getElementById('chat-input');
            const msg = input.value.trim();
            if (!msg || !currentRoom) return;

            db.ref(`ludo_rooms/${currentRoom}/chat`).push({
                sender: myName || "Unknown",
                text: msg,
                time: firebase.database.ServerValue.TIMESTAMP
            });
            input.value = "";
        }

        function initChatListener(code) {
            const chatRef = db.ref(`ludo_rooms/${code}/chat`);
            chatRef.off();
            chatRef.limitToLast(50).on('child_added', (snap) => {
                const val = snap.val();
                if (!val) return;

                const sender = val.sender || "Unknown";
                const text = val.text || "";

                const msgsDiv = document.getElementById('chat-msgs');
                const isMe = sender === myName;

                const msgEl = document.createElement('div');
                msgEl.className = 'msg';
                msgEl.style.alignSelf = isMe ? 'flex-end' : 'flex-start';
                msgEl.style.backgroundColor = isMe ? 'rgba(59, 130, 246, 0.5)' : 'rgba(255, 255, 255, 0.1)';
                msgEl.innerHTML = `<strong>${sender}</strong>: ${text}`;

                msgsDiv.appendChild(msgEl);
                msgsDiv.scrollTop = msgsDiv.scrollHeight;

                if (!isMe && document.getElementById('chat-box').classList.contains('hidden')) {
                    toast(`üì© ${sender}: ${text.substring(0, 15)}...`);
                }
            });
        }

        function enterLobby(code, color) {
            currentRoom = code;
            myColorIndex = color;
            playMode = 'online';
            showScreen('screen-lobby');
            document.getElementById('lobby-code').innerText = code;

            document.getElementById('chat-btn').style.display = 'block';
            initChatListener(code);

            // Set presence for disconnect detection
            const myPresenceRef = db.ref(`ludo_rooms/${currentRoom}/presence/${myId}`);
            myPresenceRef.set(true);
            myPresenceRef.onDisconnect().remove();

            db.ref('ludo_rooms/' + currentRoom).on('value', snap => {
                const val = snap.val();
                if (!val) return location.reload();

                // 1. Manage Bots (Host Only - Player 0)
                if (myColorIndex === 0 && val.status === 'playing' && val.presence) {
                    let dirty = false;
                    val.players.forEach((player, idx) => {
                        if (!player.isBot && !val.presence[player.id]) {
                            // Convert to bot
                            val.players[idx].name = `Bot ${idx + 1}`;
                            val.players[idx].isBot = true;
                            val.players[idx].id = `bot-${idx}`;
                            dirty = true;
                        }
                    });
                    if (dirty) {
                        db.ref(`ludo_rooms/${currentRoom}/players`).set(val.players);
                    }
                }

                // Lobby Update
                const pList = document.getElementById('lobby-players');
                pList.innerHTML = val.players.map(p => `
                    <div style="display:flex; align-items:center; justify-content:flex-end; gap:8px; margin:5px 0;">
                        <span style="font-weight:bold">${p.name}${p.isBot ? ' ü§ñ' : ''}</span>
                        <img src="https://api.dicebear.com/7.x/avataaars/svg?seed=${p.avatar || 'Felix'}" width="30" style="border-radius:50%; background:#333;">
                        <span class="d-dot" style="background:${getHexColor(p.color)}; width:10px; height:10px; display:inline-block; border-radius:50%"></span>
                    </div>`).join('');

                if (val.players[0].id === myId) document.getElementById('start-btn').classList.remove('hidden');

                // Game Start Trigger
                if (val.status === 'playing') {
                    // Preserve local state logic
                    const preserved6s = gameState.consecutive6s || 0;
                    const preservedMoves = gameState.availableMoves || [];

                    // Detect if it's a new turn or just a re-sync
                    const isSameTurnState = (gameState.turn === val.turn && gameState.dice === val.dice);

                    gameState = val;
                    gameState.consecutive6s = preserved6s;

                    if (isSameTurnState) {
                        gameState.availableMoves = preservedMoves;
                    } else {
                        gameState.availableMoves = [];
                    }

                    if (document.getElementById('screen-game').classList.contains('hidden')) {
                        showScreen('screen-game');
                    }

                    // Sync Dice Visuals
                    if (gameState.dice > 0 && !isRolling) {
                        renderDice(gameState.dice);
                    }

                    // If it's my turn, dice is rolled, but I have no moves calculated (e.g. refresh or first sync)
                    // Calculate them now!
                    const isMyTurn = (gameState.turn === myColorIndex);
                    if (isMyTurn && gameState.dice > 0 && !isRolling && gameState.availableMoves.length === 0) {
                        handleRollResult(gameState.dice);
                    }

                    updateUI(); // uses gameState.availableMoves to render Glows via renderTokens

                    // Host runs Bots logic
                    const currentPlayer = gameState.players[gameState.turn];
                    if (myColorIndex === 0 && currentPlayer && currentPlayer.isBot && !isProcessingMove) {
                        if (gameState.dice > 0) {
                            // Only run if moves not calculated yet to avoid loop
                            if (!gameState.availableMoves || gameState.availableMoves.length === 0) {
                                handleRollResult(gameState.dice);
                            }
                        } else if (!isRolling) {
                            setTimeout(() => {
                                if (gameState.players[gameState.turn].isBot && gameState.dice === 0) {
                                    performRoll();
                                }
                            }, 500);
                        }
                    }
                }

            });

            // --- BOT WATCHDOG (ANTIFREEZE) ---
            setInterval(() => {
                if (playMode !== 'online' || myColorIndex !== 0 || !gameState || !gameState.players) return;
                const cp = gameState.players[gameState.turn];
                if (cp && cp.isBot && gameState.dice === 0 && !isRolling && !isProcessingMove) {
                    console.log("[Watchdog] Forcing bot roll...");
                    performRoll();
                }
            }, 3000);
        }

        function startOnlineGame() {
            // Fill empty slots with bots (Player, Bot, Player, Bot pattern)
            db.ref('ludo_rooms/' + currentRoom).once('value', snap => {
                const room = snap.val();
                if (!room) return;

                const players = room.players || [];
                const filledPlayers = [];

                // Create 4-player array with bots filling gaps
                for (let i = 0; i < 4; i++) {
                    // Try to find a real player for this slot
                    const realPlayer = players.find(p => p.color === i);

                    if (realPlayer) {
                        filledPlayers.push(realPlayer);
                    } else {
                        // Add bot
                        const botNames = ['Bot Alpha', 'Bot Beta', 'Bot Gamma', 'Bot Delta'];
                        const botAvatars = ['Felix', 'Bear', 'Zack', 'Max'];
                        filledPlayers.push({
                            name: botNames[i] || `Bot ${i + 1}`,
                            id: 'bot-' + i,
                            color: i,
                            avatar: botAvatars[i],
                            isBot: true
                        });
                    }
                }

                // Update room with filled players
                db.ref('ludo_rooms/' + currentRoom).update({
                    status: 'playing',
                    players: filledPlayers
                });
            });
        }

        function updateOnlineState(updates) {
            if (playMode === 'online') {
                db.ref('ludo_rooms/' + currentRoom).update(updates);
            }
        }

        // --- GAME LOGIC CORES ---
        function resetBoard() {
            gameState.tokens = [[-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]];
            gameState.finished = [false, false, false, false];
            gameState.dice = 0;
            renderTokens();
        }

        function getHexColor(i) {
            return ['#22c55e', '#eab308', '#3b82f6', '#ef4444'][i];
        }

        function updateUI() {
            // Update Active Player Card
            document.querySelectorAll('.player-card').forEach((c, i) => {
                c.classList.toggle('active', i === gameState.turn);
                const p = gameState.players[i] || {};
                c.querySelector('.p-name').innerText = p.name || '---';
                if (p.avatar) c.querySelector('img').src = `https://api.dicebear.com/7.x/avataaars/svg?seed=${p.avatar}`;
                c.style.opacity = p.name ? 1 : 0.5;
            });

            // Update Dice Interaction State
            const isMyTurn = (playMode === 'online') ? (gameState.turn === myColorIndex) : (gameState.turn === 0);
            updateDiceState(isMyTurn && gameState.dice === 0 && !isRolling);

            // Render Tokens
            renderTokens();

            // Dice
            if (!isRolling) renderDice(gameState.dice || 1);
        }

        function updateDiceState(canRoll) {
            const p = document.getElementById('dice-panel');
            const m = document.getElementById('dice-msg');
            if (canRoll) {
                p.classList.remove('disabled');
                p.style.pointerEvents = 'auto';
                m.innerText = "ÿØŸàÿ±ŸÉ! ÿßÿ∂ÿ∫ÿ∑ ŸÑŸÑÿ±ŸÖŸä";
            } else {
                p.classList.add('disabled');
                p.style.pointerEvents = 'none';

                // Show who is playing
                const currentP = gameState.players[gameState.turn];
                if (currentP) {
                    m.innerText = (gameState.turn === myColorIndex || (playMode === 'offline' && gameState.turn === 0)) ? "ÿ¨ÿßÿ±Ÿä ÿßŸÑÿ±ŸÖŸä..." : `ÿØŸàÿ± ${currentP.name}`;
                }
            }
        }

        function renderDice(val) {
            if (val === 0) val = 1; // Default look
            const d = document.getElementById('dice-cube');
            d.className = 'd-' + val;
            d.classList.remove('rolling');
        }

        // Removed setDiceVisible as we now use Disabled class

        function selectAvatar(seed) {
            myAvatar = seed;
            document.querySelectorAll('.avatar-opt').forEach(d => d.style.borderColor = 'transparent');
            event.currentTarget.style.borderColor = 'var(--accent)';
        }

        function requestRoll() {
            if (isRolling) return;
            // Additional check: valid turn?
            if (playMode === 'online' && gameState.turn !== myColorIndex) return;
            if (playMode === 'offline' && gameState.turn !== 0) return;

            performRoll();
        }

        function performRoll() {
            isRolling = true;
            const btn = document.getElementById('dice-panel');
            const diceCube = document.getElementById('dice-cube');
            diceCube.classList.add('rolling');
            document.getElementById('dice-msg').innerText = "üé≤ ...";
            try { sfx.dice(); } catch (e) { }

            // Animate dice with random numbers
            let animationCount = 0;
            const animationInterval = setInterval(() => {
                const randomFace = Math.floor(Math.random() * 6) + 1;
                diceCube.className = `d-${randomFace} rolling`;
                animationCount++;

                if (animationCount >= 8) { // Stop after 8 flips
                    clearInterval(animationInterval);
                }
            }, 75); // Change face every 75ms

            setTimeout(() => {
                clearInterval(animationInterval);

                // Pure random roll (1-6)
                const roll = Math.floor(Math.random() * 6) + 1;

                console.log(`[performRoll] Player ${gameState.turn} rolled ${roll}`);

                isRolling = false;
                gameState.dice = roll;
                renderDice(roll);

                // Track consecutive 6s
                if (roll === 6) {
                    gameState.consecutive6s++;

                    // RULE: 3 consecutive 6s = lose turn
                    if (gameState.consecutive6s >= 3) {
                        console.log('[performRoll] 3 consecutive 6s! Passing turn.');
                        toast('üé≤ 3 ÿ≥ÿ™ÿßÿ™ ŸÖÿ™ÿ™ÿßŸÑŸäÿ©! ÿßŸÑÿØŸàÿ± ŸÑŸÑÿ™ÿßŸÑŸä');
                        gameState.consecutive6s = 0;
                        gameState.dice = 0;
                        setTimeout(nextTurn, 1500);
                        return;
                    }
                } else {
                    gameState.consecutive6s = 0; // Reset on non-6
                }

                if (playMode === 'online') {
                    updateOnlineState({ dice: roll });
                }

                updateUI();
                handleRollResult(roll);
            }, 600);
        }

        function handleRollResult(roll) {
            console.log(`[handleRollResult] Player ${gameState.turn} rolled ${roll}`);
            gameState.availableMoves = []; // Reset on new roll processing

            try {
                const playerId = gameState.turn;
                const pieces = gameState.tokens[playerId];
                const moveables = pieces.map((pos, idx) => canMove(playerId, idx, roll) ? idx : -1).filter(i => i !== -1);

                console.log(`[handleRollResult] Pieces: ${pieces.join(',')}, Moveable: ${moveables.join(',')}`);
                gameState.availableMoves = moveables; // UPDATE STATE

                if (moveables.length === 0) {
                    toast('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ≠ÿ±ŸÉÿßÿ™ ŸÖÿ™ÿßÿ≠ÿ©');
                    // Bonus handling if applicable (removed here, handled in moveToken or dedicated logic)
                    // But in Ludo, if no moves, you just lose turn unless it's a 6.

                    if (roll === 6) {
                        // Wait for re-roll (logic is in moveToken or nextTurn usually, but here checking moves)
                        // If I just rolled 6 and have no moves (e.g. all out but blocked?), I should roll again.
                        // But usually 6 allows getting out. 
                        // If I have no moves at all EVEN with 6 (game logic), then simple re-roll?
                        // Assuming standard logic:
                        if (playMode === 'offline' && gameState.turn !== 0) {
                            setTimeout(() => performRoll(), 500);
                        } else {
                            // User must roll again
                            updateUI();
                        }
                    } else {
                        setTimeout(nextTurn, 500);
                    }
                } else if (moveables.length === 1) {
                    // --- AUTO MOVE ---
                    updateUI();
                    setTimeout(() => moveToken(playerId, moveables[0]), 300);
                } else {
                    // Just Sync UI - renderTokens will glow them based on availableMoves
                    updateUI();

                    // Check if current player is a bot
                    const currentPlayer = gameState.players[gameState.turn];
                    const isBot = (playMode === 'offline' && gameState.turn !== 0) ||
                        (playMode === 'online' && currentPlayer && (currentPlayer.isBot || currentPlayer.id.startsWith('bot-')));

                    // Host runs Bots in Online (Only Host Player 0)
                    if (playMode === 'online' && myColorIndex !== 0 && isBot) return;

                    if (isBot && !isAIProcessing) {
                        isAIProcessing = true;
                        setTimeout(() => runAI(moveables, playerId), 400);
                    }
                }
            } catch (err) {
                console.error("[handleRollResult] Error:", err);
                toast("ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ÿå ÿ™ÿ¨ÿßŸàÿ≤ ÿßŸÑÿØŸàÿ±");
                nextTurn();
            }
        }

        let isAIProcessing = false;

        function runAI(options, pid) {
            try {
                // If processing another move, wait and retry instead of giving up
                // But if retrying too much, force break the lock
                if (isProcessingMove && !options._retried) {
                    console.log("[runAI] Move lock active, retrying in 200ms...");
                    options._retried = true; // Mark as retried
                    setTimeout(() => runAI(options, pid), 200);
                    return;
                }

                // Force release lock if still stuck after retry
                if (isProcessingMove) {
                    console.warn("[runAI] Force releasing lock for Bot Move");
                    isProcessingMove = false;
                }

                if (!options || options.length === 0) {
                    isAIProcessing = false;
                    nextTurn();
                    return;
                }

                const pick = options[Math.floor(Math.random() * options.length)];
                console.log(`[runAI] Bot moves token ${pick} (PID: ${pid})`);

                moveToken(pid !== undefined ? pid : gameState.turn, pick);
                isAIProcessing = false; // RESET immediately after move
            } catch (err) {
                console.error("AI Error:", err);
                isAIProcessing = false;
                nextTurn();
            }
        }

        // --- GAME LOGIC ---
        function canMove(pid, tid, roll) {
            const pos = gameState.tokens[pid][tid];
            if (pos === -1) return (roll === 6);
            if (pos >= 100) return false;
            // Goal Logic (Standard 57 limit: 0-51 common, 52-56 home, 57 goal)
            if (pos === 56) return false;
            if (pos + roll > 56) return false;
            return true;
        }

        function toGlobal(pid, localPos) {
            // 52 Common Steps Logic
            if (localPos >= 52) return -1;
            const globalStartOffset = pid * 13;
            return (globalStartOffset + localPos) % 52;
        }

        function isSafe(globalPos) {
            // 52-track Safe Spots (Offsets: Start +0, Star +8)
            // Green: 0, 8
            // Yellow: 13, 21
            // Blue: 26, 34
            // Red: 39, 47
            const safes = [0, 8, 13, 21, 26, 34, 39, 47];
            return safes.includes(globalPos);
        }

        function moveToken(pid, tid) {
            // STRICT TURN CHECK
            if (pid !== gameState.turn) {
                console.warn(`[moveToken] REJECTED: Player ${pid} tried to move on Player ${gameState.turn}'s turn.`);
                return;
            }
            console.log(`[moveToken] Player ${pid} moving piece ${tid}, current dice: ${gameState.dice}`);

            // Processing Lock
            if (isProcessingMove) {
                if (pid === 0 && playMode === 'offline') {
                    console.log('[moveToken] Blocking human spam click');
                    return;
                }
                if (pid === myColorIndex && playMode === 'online') {
                    console.log('[moveToken] Blocking online human spam click');
                    return;
                }
                console.warn("[moveToken] Force releasing lock for bot/auto move");
                isProcessingMove = false;
            }
            isProcessingMove = true;

            document.querySelectorAll('.glow').forEach(e => e.classList.remove('glow'));
            document.querySelectorAll('.token').forEach(e => e.style.animation = '');

            const roll = gameState.dice;
            let currentLocal = gameState.tokens[pid][tid];
            let previousState = currentLocal;

            // 1. Move Physics
            try {
                if (currentLocal === -1) {
                    currentLocal = 0; // Exit Base
                    try { sfx.move(); } catch (e) { }
                } else {
                    currentLocal += roll;
                    try { sfx.move(); } catch (e) { }
                }
            } catch (e) { console.error("Move Error", e); }

            gameState.tokens[pid][tid] = currentLocal;

            // Check Interactions
            // 2. Interaction (Kill Checks)
            // Rules: 
            // - Safe Spot (Star/Start) -> No Kill (Coexist)
            // - Protected Stack (>1 opponent) -> No Kill (Coexist)
            // - Vulnerable (1 opponent) -> Kill
            if (currentLocal < 52) {
                const myGlobal = toGlobal(pid, currentLocal);
                // IF NOT SAFE SPOT
                if (myGlobal !== -1 && !isSafe(myGlobal)) {
                    let killedAny = false;
                    // Check enemies
                    for (let op = 0; op < 4; op++) {
                        if (op === pid) continue;

                        let opTokens = [];
                        gameState.tokens[op].forEach((pos, idx) => {
                            if (pos !== -1 && pos < 52 && toGlobal(op, pos) === myGlobal) {
                                opTokens.push(idx);
                            }
                        });

                        // KILL ONLY IF SINGLE
                        if (opTokens.length === 1) {
                            gameState.tokens[op][opTokens[0]] = -1; // Kill
                            killedAny = true;
                        }
                    }

                    if (killedAny) {
                        try { sfx.kill(); toast("üí• ÿ£ŸÉŸÑÿ™ ÿßŸÑŸÖŸÜÿßŸÅÿ≥!"); showConfetti(5); } catch (e) { }
                    }
                }
            }

            if (currentLocal >= 57) { // Goal
                currentLocal = 57;
                gameState.tokens[pid][tid] = 57;
                checkWin(pid);
            }

            // Check if player has finished all pieces
            if (!gameState.finished) gameState.finished = [false, false, false, false];
            const playerFinished = gameState.finished[pid];

            renderTokens();

            setTimeout(() => isProcessingMove = false, 400);

            // 4. Turn Flow
            const bonus = (roll === 6 || currentLocal === 57);
            console.log(`[moveToken] Bonus turn? ${bonus} (roll=${roll}, pos=${currentLocal})`);

            if (bonus) {
                console.log('[moveToken] GRANTING BONUS TURN');
                if (currentLocal === 57 && !playerFinished) toast("ŸàÿµŸÑÿ™! üèÅ");
                else if (roll === 6) toast("ŸÑŸÅÿ© ÿ•ÿ∂ÿßŸÅŸäÿ©! üé≤");

                if (playerFinished) {
                    console.log('[moveToken] Player finished, passing turn');
                    nextTurn();
                } else {
                    // Re-Roll
                    console.log('[moveToken] Resetting dice for bonus roll');
                    gameState.dice = 0;
                    if (playMode === 'online') {
                        updateOnlineState(gameState);
                    } else {
                        updateUI();
                        if (playMode === 'offline' && gameState.turn !== 0) {
                            console.log('[moveToken] Bot auto-rolling after 800ms');
                            setTimeout(() => performRoll(), 800);
                        } else {
                            console.log('[moveToken] Player can roll again manually');
                        }
                    }
                }
            } else {
                console.log('[moveToken] NO bonus, passing turn after 200ms');
                setTimeout(nextTurn, 200);
            }
        }

        function checkWin(pid) {
            const allHome = gameState.tokens[pid].every(t => t >= 56);
            if (allHome && !gameState.finished[pid]) {
                gameState.finished[pid] = true;
                toast(`üèÜ ${gameState.players[pid].name} Wins!`);
                sfx.win();
                showConfetti(50);
            }
        }

        function nextTurn() {
            gameState.dice = 0;
            isAIProcessing = false; // Reset AI Lock
            // Ensure finished array exists to prevent crash
            if (!gameState.finished) gameState.finished = [false, false, false, false];

            let checks = 0;
            do {
                gameState.turn = (gameState.turn + 1) % 4;
                checks++;
            } while (gameState.finished[gameState.turn] && checks < 4);

            if (playMode === 'online') {
                updateOnlineState(gameState);
            } else {
                updateUI();
                if (gameState.turn !== 0 && !gameState.finished[gameState.turn]) {
                    setTimeout(() => performRoll(), 1000);
                }
            }
        }

        // --- RENDER ---
        function renderTokens() {
            const layer = document.getElementById('tokens-layer');
            const ghostLayer = document.getElementById('ghost-layer');
            layer.innerHTML = "";
            ghostLayer.innerHTML = "";

            const map = {};
            for (let p = 0; p < 4; p++) {
                gameState.tokens[p].forEach((pos, tId) => {
                    const xy = getCoordinates(p, pos, tId);
                    const key = Math.round(xy.x) + "," + Math.round(xy.y);
                    if (!map[key]) map[key] = [];
                    map[key].push({ p, tId });
                });
            }

            // Draw
            for (let key in map) {
                const stack = map[key];
                stack.sort((a, b) => (a.p - b.p) || (a.tId - b.tId));

                stack.forEach((d, i) => {
                    const xy = key.split(',');
                    const el = document.createElement('div');
                    el.className = `token ${colors[d.p]}`;
                    el.id = `t-${d.p}-${d.tId}`;

                    let offX = 0, offY = 0;
                    if (stack.length > 1) {
                        const angle = (i / stack.length) * Math.PI * 2;
                        const dist = 14;
                        offX = Math.cos(angle) * dist;
                        offY = Math.sin(angle) * dist;
                    }

                    el.style.left = (parseFloat(xy[0]) + offX) + 'px';
                    el.style.top = (parseFloat(xy[1]) + offY) + 'px';

                    // Touch/Click Interaction
                    const handleInteraction = (e) => {
                        e.stopPropagation();
                        // e.preventDefault(); // CAREFUL: This might block scrolling if not careful. 
                        // But for a game token, preventing default on touch is usually what we want to stop ghost clicks.

                        if (playMode === 'online' && gameState.turn !== myColorIndex) return toast("ŸÑŸäÿ≥ ÿØŸàÿ±ŸÉ!");
                        if (playMode === 'offline' && gameState.turn !== 0 && d.p !== 0) return;
                        if (gameState.dice === 0 || isRolling) return toast("ÿßÿ±ŸÖŸê ÿßŸÑŸÜÿ±ÿØ ÿ£ŸàŸÑÿßŸã!");
                        if (d.p !== gameState.turn) return toast("Ÿáÿ∞Ÿá ŸÑŸäÿ≥ÿ™ ŸÇÿ∑ÿπÿ™ŸÉ!");

                        if (canMove(d.p, d.tId, gameState.dice)) {
                            // Valid Move
                            // Hide ghost immediately
                            ghostLayer.innerHTML = "";
                            moveToken(d.p, d.tId);
                        } else {
                            const pos = gameState.tokens[d.p][d.tId];
                            if (pos === -1 && gameState.dice !== 6) toast("ÿ™ÿ≠ÿ™ÿßÿ¨ 6 ŸÑŸÑÿÆÿ±Ÿàÿ¨! üé≤");
                            else toast("ÿ≠ÿ±ŸÉÿ© ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ÿ©!");
                        }
                    };

                    el.onclick = handleInteraction;
                    // Add touch support for instant reaction
                    el.ontouchend = (e) => {
                        // Prevent mouse emulation (double firing)
                        e.preventDefault();
                        handleInteraction(e);
                    };

                    const myTurn = (playMode === 'online' ? gameState.turn === myColorIndex : gameState.turn === 0);

                    // NEW: Check state for moveability instead of ad-hoc checks
                    // This ensures highlights survive Firebase updates
                    const isMoveable = (gameState.availableMoves || []).includes(d.tId) && d.p === gameState.turn;
                    const canM = (myTurn && !isRolling && gameState.dice > 0 && isMoveable);

                    if (canM) {
                        el.style.cursor = "pointer";
                        el.classList.add('glow');
                        el.style.zIndex = 999;
                        // Desktop Hover only
                        el.onmouseenter = () => showGhost(d.p, gameState.tokens[d.p][d.tId], gameState.dice);
                        el.onmouseleave = () => ghostLayer.innerHTML = "";
                    } else {
                        el.style.cursor = "default";
                        el.style.zIndex = 200 + i;
                    }

                    layer.appendChild(el);
                });
            }
        }

        function showGhost(pid, currentPos, roll) {
            if (roll === 0) return;
            let nextPos = (currentPos === -1) ? 0 : currentPos + roll;
            if (nextPos > 56) return;

            const xy = getCoordinates(pid, nextPos, 0);
            const g = document.createElement('div');
            g.className = 'ghost-token';
            g.style.left = xy.x + 'px';
            g.style.top = xy.y + 'px';
            document.getElementById('ghost-layer').appendChild(g);
        }

        function getCoordinates(pid, pos, tokenIndex) {
            const bases = [
                [[180, 180], [320, 180], [180, 320], [320, 320]],
                [[1080, 180], [1220, 180], [1080, 320], [1220, 320]],
                [[1080, 1080], [1220, 1080], [1080, 1220], [1220, 1220]],
                [[180, 1080], [320, 1080], [180, 1220], [320, 1220]]
            ];

            if (pos === -1) {
                const b = bases[pid][tokenIndex];
                const wrapper = document.getElementById('game-container').offsetWidth;
                const px = (b[0] / 1500) * 100;
                const py = (b[1] / 1500) * 100;
                return { x: px * (wrapper / 100), y: py * (wrapper / 100) };
            }

            if (pos >= 56) {
                const wrapper = document.getElementById('game-container').offsetWidth;
                const center = wrapper / 2;
                const offset = wrapper * 0.05;
                if (pid === 0) return { x: center - offset, y: center - offset };
                if (pid === 1) return { x: center + offset, y: center - offset };
                if (pid === 2) return { x: center + offset, y: center + offset };
                if (pid === 3) return { x: center - offset, y: center + offset };
                return { x: center, y: center };
            }

            const track = getPathForPlayer(pid);
            if (pos < track.length) {
                const pt = track[pos];
                const sx = (pt[0] * 100 + 50);
                const sy = (pt[1] * 100 + 50);
                const wrapper = document.getElementById('game-container').offsetWidth;

                // DEBUG: Log start square positions
                if (pos === 0) {
                    console.log(`[getCoordinates] Player ${pid} start square: grid[${pt[0]}, ${pt[1]}] => screen[${sx}, ${sy}]`);
                }

                return { x: (sx / 1500) * wrapper, y: (sy / 1500) * wrapper };
            }
            return { x: 0, y: 0 };
        }

        function getPathForPlayer(pid) {
            // Correct 52-square track with proper start positions
            const track = [];

            // GREEN zone (positions 0-12)
            track.push([1, 6]);   // 0: GREEN START ‚òÖ
            track.push([2, 6]);   // 1
            track.push([3, 6]);   // 2
            track.push([4, 6]);   // 3
            track.push([5, 6]);   // 4
            track.push([6, 5]);   // 5
            track.push([6, 4]);   // 6
            track.push([6, 3]);   // 7
            track.push([6, 2]);   // 8: Safe (Star)
            track.push([6, 1]);   // 9
            track.push([6, 0]);   // 10
            track.push([7, 0]);   // 11
            track.push([8, 0]);   // 12

            // YELLOW zone (positions 13-25)
            track.push([8, 1]);   // 13: YELLOW START ‚òÖ
            track.push([8, 2]);   // 14
            track.push([8, 3]);   // 15
            track.push([8, 4]);   // 16
            track.push([8, 5]);   // 17
            track.push([9, 6]);   // 18
            track.push([10, 6]);  // 19
            track.push([11, 6]);  // 20
            track.push([12, 6]);  // 21: Safe (Star)
            track.push([13, 6]);  // 22
            track.push([14, 6]);  // 23
            track.push([14, 7]);  // 24
            track.push([14, 8]);  // 25

            // BLUE zone (positions 26-38)  
            track.push([13, 8]);  // 26: BLUE START ‚òÖ
            track.push([12, 8]);  // 27
            track.push([11, 8]);  // 28
            track.push([10, 8]);  // 29
            track.push([9, 8]);   // 30
            track.push([8, 9]);   // 31
            track.push([8, 10]);  // 32
            track.push([8, 11]);  // 33
            track.push([8, 12]);  // 34: Safe (Star)
            track.push([8, 13]);  // 35
            track.push([8, 14]);  // 36
            track.push([7, 14]);  // 37
            track.push([6, 14]);  // 38

            // RED zone (positions 39-51)
            track.push([6, 13]);  // 39: RED START ‚òÖ
            track.push([6, 12]);  // 40
            track.push([6, 11]);  // 41
            track.push([6, 10]);  // 42
            track.push([6, 9]);   // 43
            track.push([5, 8]);   // 44
            track.push([4, 8]);   // 45
            track.push([3, 8]);   // 46
            track.push([2, 8]);   // 47: Safe (Star)
            track.push([1, 8]);   // 48
            track.push([0, 8]);   // 49
            track.push([0, 7]);   // 50 (Just before home entry)

            // Home stretches
            // Home stretches (Reduced to 6 steps: 5 Colors + 1 Goal)
            const homeStretches = [
                [[1, 7], [2, 7], [3, 7], [4, 7], [5, 7], [7, 7]],  // GREEN
                [[7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 7]],  // YELLOW
                [[13, 7], [12, 7], [11, 7], [10, 7], [9, 7], [7, 7]], // BLUE
                [[7, 13], [7, 12], [7, 11], [7, 10], [7, 9], [7, 7]]  // RED
            ];

            // Build player-specific path (rotated start)
            const startOffset = pid * 13;
            const playerTrack = [];

            for (let i = 0; i < 51; i++) {
                const idx = (startOffset + i) % 52; // CORRECT: Modulo 52 (Track length)
                playerTrack.push(track[idx]);
            }

            return playerTrack.concat(homeStretches[pid]);
        }



        // --- CHAT & UTILS ---
        function toast(msg) {
            const t = document.getElementById('toast');
            document.getElementById('toast-msg').innerText = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 3000);
        }

        function copyCode() {
            navigator.clipboard.writeText(currentRoom);
            toast("ÿ™ŸÖ ŸÜÿ≥ÿÆ ÿßŸÑŸÉŸàÿØ! üìã");
        }

        function showConfetti() {
            for (let i = 0; i < 30; i++) {
                const c = document.createElement('div');
                c.className = 'confetti';
                c.style.left = Math.random() * 100 + 'vw';
                c.style.backgroundColor = ['red', 'yellow', 'green', 'blue'][Math.floor(Math.random() * 4)];
                c.style.animationDuration = (Math.random() * 2 + 2) + 's';
                document.body.appendChild(c);
                setTimeout(() => c.remove(), 4000);
            }
        }

        // Chat
        function toggleChat() {
            const b = document.getElementById('chat-box');
            b.classList.toggle('open');
            if (b.classList.contains('open')) b.classList.remove('hidden');
        }

        function sendChat() {
            const inp = document.getElementById('chat-input');
            const txt = inp.value.trim();
            if (!txt) return;
            // Send
            if (playMode === 'online') db.ref('ludo_rooms/' + currentRoom + '/chat').push({ n: myName, m: txt });
            else { // Local Echo
                addMsg(myName, txt);
            }
            inp.value = "";
        }

        function addMsg(n, m) {
            const d = document.getElementById('chat-msgs');
            d.innerHTML += `<div class="msg"><b>${n}:</b> ${m}</div>`;
            d.scrollTop = d.scrollHeight;
        }

        // ===== 15 ENHANCEMENTS =====
        // Game Statistics Tracking
        let gameStats = {
            moveCount: [0, 0, 0, 0],
            killCount: [0, 0, 0, 0],
            sixCount: [0, 0, 0, 0],
            totalRolls: [0, 0, 0, 0]
        };

        let moveHistory = [];
        let turnTimer = null;
        let turnTimeRemaining = 30;

        // Fullscreen Toggle
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Fullscreen not supported');
                });
            } else {
                document.exitFullscreen();
            }
        }

        // Turn Timer
        function startTurnTimer() {
            turnTimeRemaining = 30;
            if (turnTimer) clearInterval(turnTimer);

            turnTimer = setInterval(() => {
                turnTimeRemaining--;
                document.getElementById('timer-value').innerText = turnTimeRemaining;

                if (turnTimeRemaining === 0) {
                    clearInterval(turnTimer);
                    if (playMode === 'offline' && gameState.turn !== 0) {
                        toast('‚è±Ô∏è ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™!');
                        nextTurn();
                    }
                }
            }, 1000);
        }

        // Update Statistics Display
        function updateStats() {
            const currentPlayer = gameState.turn;
            const stats = `üé≤ ${gameStats.totalRolls[currentPlayer]} | ‚≠ê ${gameStats.sixCount[currentPlayer]} | üö∂ ${gameStats.moveCount[currentPlayer]} | üí• ${gameStats.killCount[currentPlayer]}`;
            document.getElementById('stats-content').innerHTML = stats;
        }

        // Add Move to History
        function addToHistory(playerName, action) {
            const timestamp = new Date().toLocaleTimeString('ar-EG', { hour: '2-digit', minute: '2-digit' });
            moveHistory.unshift({ player: playerName, action, time: timestamp });

            if (moveHistory.length > 5) moveHistory.pop();

            const historyHTML = moveHistory.map(h =>
                `<div style="margin-bottom: 3px; color: #e2e8f0;">${h.time} - ${h.player}: ${h.action}</div>`
            ).join('');

            document.getElementById('history-list').innerHTML = historyHTML;
        }

        // Create Particle Effect
        function createParticles(x, y, color, count = 15) {
            const container = document.getElementById('particles-container');

            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                const angle = (Math.PI * 2 * i) / count;
                const velocity = 30 + Math.random() * 40;
                const vx = Math.cos(angle) * velocity;
                const vy = Math.sin(angle) * velocity;

                particle.style.cssText = `
                    position: absolute;
                    left: ${x}px;
                    top: ${y}px;
                    width: 6px;
                    height: 6px;
                    background: ${color};
                    border-radius: 50%;
                    pointer-events: none;
                    transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
                    opacity: 1;
                `;

                container.appendChild(particle);

                setTimeout(() => {
                    particle.style.transform = `translate(${vx}px, ${vy + 50}px)`;
                    particle.style.opacity = '0';
                }, 50);

                setTimeout(() => particle.remove(), 900);
            }
        }

        // Victory Dance
        function victoryDance(playerId) {
            const playerCard = document.getElementById(`p-card-${playerId}`);
            if (playerCard) {
                playerCard.style.animation = 'none';
                setTimeout(() => {
                    playerCard.style.animation = 'pulse 0.5s ease-in-out 3';
                }, 10);
            }
        }

        // Initialize enhancements on game start
        function initEnhancements() {
            updateStats();
            startTurnTimer();
            addToHistory('ÿßŸÑŸÜÿ∏ÿßŸÖ', 'ÿßŸÑŸÑÿπÿ®ÿ© ÿ®ÿØÿ£ÿ™! üéÆ');
        }

        // Online Listeners extras
        // Note: Full sync logic handles most. Chat needs separate listener if online.

    </script>
</body>

</html>
